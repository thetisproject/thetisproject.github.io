
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>thetis.utility &#8212; Thetis 0+untagged.1793.g290af40 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thetis.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<!-- <link rel="stylesheet" href="../../_static/featured.css"> -->


<link rel="shortcut icon" href="../../_static/icon_thetis.ico" />


  </head><body>
<div class="wrapper">
  <a href="../../index.html"><img src="../../_static/banner.jpg" height="180px" alt="Thetis Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
        <li class="page_item"><a href="../../documentation.html" title="Thetis documentation">Documentation</a></li>
        <li class="page_item"><a href="../../download.html" title="Install Thetis">Download</a></li>
        <li class="page_item"><a href="../../team.html" title="Development team">Team</a></li>
        <li class="page_item"><a href="../../publications.html" title="Publications">Publications</a></li>
        <li class="page_item"><a href="../../funding.html" title="Our financial supporters">Funding</a></li>
        <li class="page_item"><a href="../../contact.html" title="Getting in touch">Contact</a></li>
        <li class="page_item"><a href="https://github.com/thetisproject/thetis" title="Thetis source on GitHub">GitHub</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="_modules/thetis/utility">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for thetis.utility</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utility functions and classes for 2D and 3D ocean models</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">namedtuple</span>  <span class="c1"># NOQA</span>

<span class="kn">import</span> <span class="nn">coffee.base</span> <span class="k">as</span> <span class="nn">ast</span>  <span class="c1"># NOQA</span>
<span class="kn">import</span> <span class="nn">ufl</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">firedrake.petsc</span> <span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">pyop2.profiling</span> <span class="kn">import</span> <span class="n">timed_function</span><span class="p">,</span> <span class="n">timed_region</span><span class="p">,</span> <span class="n">timed_stage</span>  <span class="c1"># NOQA</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="kn">from</span> <span class="nn">.field_defs</span> <span class="kn">import</span> <span class="n">field_metadata</span>
<span class="kn">from</span> <span class="nn">.log</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.physical_constants</span> <span class="kn">import</span> <span class="n">physical_constants</span>

<span class="n">ds_surf</span> <span class="o">=</span> <span class="n">ds_t</span>
<span class="n">ds_bottom</span> <span class="o">=</span> <span class="n">ds_b</span>


<div class="viewcode-block" id="FrozenClass"><a class="viewcode-back" href="../../thetis.html#thetis.utility.FrozenClass">[docs]</a><span class="k">class</span> <span class="nc">FrozenClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class where creating a new attribute will raise an exception if</span>
<span class="sd">    :attr:`_isfrozen` is ``True``.</span>

<span class="sd">    :attr:`_unfreezedepth` allows for multiple applications of the</span>
<span class="sd">    ``unfrozen`` decorator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_isfrozen</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_unfreezedepth</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isfrozen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Adding new attribute &quot;</span><span class="si">{:}</span><span class="s1">&quot; to </span><span class="si">{:}</span><span class="s1"> class is forbidden&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FrozenClass</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="unfrozen"><a class="viewcode-back" href="../../thetis.html#thetis.utility.unfrozen">[docs]</a><span class="k">def</span> <span class="nf">unfrozen</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to temporarily unfreeze an object</span>
<span class="sd">    whilst one of its methods is being called.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isfrozen</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfreezedepth</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfreezedepth</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isfrozen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unfreezedepth</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>


<div class="viewcode-block" id="SumFunction"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SumFunction">[docs]</a><span class="k">class</span> <span class="nc">SumFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper class to keep track of sum of Coefficients.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize empty sum.</span>

<span class="sd">        get operation returns Constant(0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="SumFunction.add"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SumFunction.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a coefficient to self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span></div>

<div class="viewcode-block" id="SumFunction.get_sum"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SumFunction.get_sum">[docs]</a>    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a sum of all added Coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AttrDict"><a class="viewcode-back" href="../../thetis.html#thetis.utility.AttrDict">[docs]</a><span class="k">class</span> <span class="nc">AttrDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary that provides both self[&#39;key&#39;] and self.key access to members.</span>

<span class="sd">    http://stackoverflow.com/questions/4984647/accessing-dict-keys-like-an-attribute-in-python</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;AttrDict requires python &gt;= 2.7.4 to avoid memory leaks&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="FieldDict"><a class="viewcode-back" href="../../thetis.html#thetis.utility.FieldDict">[docs]</a><span class="k">class</span> <span class="nc">FieldDict</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    AttrDict that checks that all added fields have proper meta data.</span>

<span class="sd">    Values can be either Function or Constant objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_check_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">firedrake.functionspaceimpl</span> <span class="kn">import</span> <span class="p">(</span><span class="n">MixedFunctionSpace</span><span class="p">,</span>
                                                     <span class="n">WithGeometry</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Value must be a Function or Constant object&#39;</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
            <span class="n">is_mixed</span> <span class="o">=</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">MixedFunctionSpace</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">WithGeometry</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">topological</span><span class="p">,</span> <span class="n">MixedFunctionSpace</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_mixed</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">field_metadata</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Trying to add a field &quot;</span><span class="si">{:}</span><span class="s1">&quot; that has no metadata. &#39;</span> \
                      <span class="s1">&#39;Add field_metadata entry to field_defs.py&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_functionname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set function.name to key to ensure consistent naming&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="n">value</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inputs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_functionname</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FieldDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inputs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_functionname</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FieldDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_functionspace"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_functionspace">[docs]</a><span class="k">def</span> <span class="nf">get_functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">h_family</span><span class="p">,</span> <span class="n">h_degree</span><span class="p">,</span> <span class="n">v_family</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">vector</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hdiv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v_variant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">cell_dim</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cell_dimension</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">cell_dim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="s1">&#39;Unsupported cell dimension&#39;</span>
    <span class="n">hdiv_families</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;RT&#39;</span><span class="p">,</span> <span class="s1">&#39;RTF&#39;</span><span class="p">,</span> <span class="s1">&#39;RTCF&#39;</span><span class="p">,</span> <span class="s1">&#39;RAVIART-THOMAS&#39;</span><span class="p">,</span>
        <span class="s1">&#39;BDM&#39;</span><span class="p">,</span> <span class="s1">&#39;BDMF&#39;</span><span class="p">,</span> <span class="s1">&#39;BDMCF&#39;</span><span class="p">,</span> <span class="s1">&#39;BREZZI-DOUGLAS-MARINI&#39;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">variant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">h_family</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="n">hdiv_families</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h_family</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RTCF&#39;</span><span class="p">,</span> <span class="s1">&#39;BDMCF&#39;</span><span class="p">]:</span>
                <span class="n">variant</span> <span class="o">=</span> <span class="s1">&#39;equispaced&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variant</span> <span class="o">=</span> <span class="s1">&#39;integral&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variant</span> <span class="o">=</span> <span class="s1">&#39;equispaced&#39;</span>
    <span class="k">if</span> <span class="n">v_variant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v_variant</span> <span class="o">=</span> <span class="s1">&#39;equispaced&#39;</span>
    <span class="k">if</span> <span class="n">cell_dim</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v_family</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v_family</span> <span class="o">=</span> <span class="n">h_family</span>
        <span class="k">if</span> <span class="n">v_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v_degree</span> <span class="o">=</span> <span class="n">h_degree</span>
        <span class="n">h_cell</span><span class="p">,</span> <span class="n">v_cell</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">()</span><span class="o">.</span><span class="n">sub_cells</span><span class="p">()</span>
        <span class="n">h_elt</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">h_family</span><span class="p">,</span> <span class="n">h_cell</span><span class="p">,</span> <span class="n">h_degree</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="n">variant</span><span class="p">)</span>
        <span class="n">v_elt</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">v_family</span><span class="p">,</span> <span class="n">v_cell</span><span class="p">,</span> <span class="n">v_degree</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="n">v_variant</span><span class="p">)</span>
        <span class="n">elt</span> <span class="o">=</span> <span class="n">TensorProductElement</span><span class="p">(</span><span class="n">h_elt</span><span class="p">,</span> <span class="n">v_elt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hdiv</span><span class="p">:</span>
            <span class="n">elt</span> <span class="o">=</span> <span class="n">HDiv</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">elt</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">h_family</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">(),</span> <span class="n">h_degree</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="n">variant</span><span class="p">)</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">vector</span> <span class="ow">and</span> <span class="n">tensor</span><span class="p">)</span>
    <span class="n">constructor</span> <span class="o">=</span> <span class="n">TensorFunctionSpace</span> <span class="k">if</span> <span class="n">tensor</span> <span class="k">else</span> <span class="n">VectorFunctionSpace</span> <span class="k">if</span> <span class="n">vector</span> <span class="k">else</span> <span class="n">FunctionSpace</span>
    <span class="k">return</span> <span class="n">constructor</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">elt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_extruded_base_element"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_extruded_base_element">[docs]</a><span class="k">def</span> <span class="nf">get_extruded_base_element</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return UFL TensorProductElement of an extruded UFL element.</span>

<span class="sd">    In case of a non-extruded mesh, returns the element itself.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">HDivElement</span><span class="p">):</span>
        <span class="n">ufl_element</span> <span class="o">=</span> <span class="n">ufl_element</span><span class="o">.</span><span class="n">_element</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">MixedElement</span><span class="p">):</span>
        <span class="n">ufl_element</span> <span class="o">=</span> <span class="n">ufl_element</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">VectorElement</span><span class="p">):</span>
        <span class="n">ufl_element</span> <span class="o">=</span> <span class="n">ufl_element</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># take the first component</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">EnrichedElement</span><span class="p">):</span>
        <span class="n">ufl_element</span> <span class="o">=</span> <span class="n">ufl_element</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ufl_element</span></div>


<span class="n">ElementContinuity</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;ElementContinuity&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;horizontal&quot;</span><span class="p">,</span> <span class="s2">&quot;vertical&quot;</span><span class="p">])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A named tuple describing the continuity of an element in the horizontal/vertical direction.</span>

<span class="sd">The field value is one of &quot;cg&quot;, &quot;hdiv&quot;, or &quot;dg&quot;.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="element_continuity"><a class="viewcode-back" href="../../thetis.html#thetis.utility.element_continuity">[docs]</a><span class="k">def</span> <span class="nf">element_continuity</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an :class:`ElementContinuity` instance with the</span>
<span class="sd">    continuity of a given element.</span>

<span class="sd">    :arg ufl_element: The UFL element to determine the continuity</span>
<span class="sd">        of.</span>
<span class="sd">    :returns: A new :class:`ElementContinuity` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">ufl_element</span>
    <span class="n">elem_types</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Discontinuous Lagrange&#39;</span><span class="p">:</span> <span class="s1">&#39;dg&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Lagrange&#39;</span><span class="p">:</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Raviart-Thomas&#39;</span><span class="p">:</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;RTCF&#39;</span><span class="p">:</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Brezzi-Douglas-Marini&#39;</span><span class="p">:</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;BDMCF&#39;</span><span class="p">:</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span>
        <span class="s1">&#39;DQ&#39;</span><span class="p">:</span> <span class="s1">&#39;dg&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">base_element</span> <span class="o">=</span> <span class="n">get_extruded_base_element</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">HDivElement</span><span class="p">):</span>
        <span class="n">horiz_type</span> <span class="o">=</span> <span class="s1">&#39;hdiv&#39;</span>
        <span class="n">vert_type</span> <span class="o">=</span> <span class="s1">&#39;hdiv&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_element</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TensorProductElement</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">base_element</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()</span>
        <span class="n">horiz_type</span> <span class="o">=</span> <span class="n">elem_types</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">family</span><span class="p">()]</span>
        <span class="n">vert_type</span> <span class="o">=</span> <span class="n">elem_types</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">family</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">horiz_type</span> <span class="o">=</span> <span class="n">elem_types</span><span class="p">[</span><span class="n">base_element</span><span class="o">.</span><span class="n">family</span><span class="p">()]</span>
        <span class="n">vert_type</span> <span class="o">=</span> <span class="n">horiz_type</span>
    <span class="k">return</span> <span class="n">ElementContinuity</span><span class="p">(</span><span class="n">horiz_type</span><span class="p">,</span> <span class="n">vert_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_directory"><a class="viewcode-back" href="../../thetis.html#thetis.utility.create_directory">[docs]</a><span class="k">def</span> <span class="nf">create_directory</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">COMM_WORLD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a directory on disk</span>

<span class="sd">    Raises IOError if a file with the same name already exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;file with same name exists&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">path</span></div>


<div class="viewcode-block" id="get_facet_mask"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_facet_mask">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_facet_mask&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_facet_mask</span><span class="p">(</span><span class="n">function_space</span><span class="p">,</span> <span class="n">facet</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the top/bottom nodes of extruded 3D elements.</span>

<span class="sd">    :arg function_space: Firedrake :class:`FunctionSpace` object</span>
<span class="sd">    :kwarg str facet: &#39;top&#39; or &#39;bottom&#39;</span>

<span class="sd">    .. note::</span>
<span class="sd">        The definition of top/bottom depends on the direction of the extrusion.</span>
<span class="sd">        Here we assume that the mesh has been extruded upwards (along positive</span>
<span class="sd">        z axis).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">tsfc.finatinterface</span> <span class="kn">import</span> <span class="n">create_element</span> <span class="k">as</span> <span class="n">create_finat_element</span>

    <span class="c1"># get base element</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">get_extruded_base_element</span><span class="p">(</span><span class="n">function_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">TensorProductElement</span><span class="p">),</span> \
        <span class="sa">f</span><span class="s1">&#39;function space must be defined on an extruded 3D mesh: </span><span class="si">{</span><span class="n">elem</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="c1"># figure out number of nodes in sub elements</span>
    <span class="n">h_elt</span><span class="p">,</span> <span class="n">v_elt</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()</span>
    <span class="n">nb_nodes_h</span> <span class="o">=</span> <span class="n">create_finat_element</span><span class="p">(</span><span class="n">h_elt</span><span class="p">)</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>
    <span class="n">nb_nodes_v</span> <span class="o">=</span> <span class="n">create_finat_element</span><span class="p">(</span><span class="n">v_elt</span><span class="p">)</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>
    <span class="c1"># compute top/bottom facet indices</span>
    <span class="c1"># extruded dimension is the inner loop in index</span>
    <span class="c1"># on interval elements, the end points are the first two dofs</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">facet</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nb_nodes_h</span><span class="p">)</span><span class="o">*</span><span class="n">nb_nodes_v</span> <span class="o">+</span> <span class="n">offset</span>
    <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="extrude_mesh_sigma"><a class="viewcode-back" href="../../thetis.html#thetis.utility.extrude_mesh_sigma">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.extrude_mesh_sigma&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extrude_mesh_sigma</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">,</span> <span class="n">bathymetry_2d</span><span class="p">,</span> <span class="n">z_stretch_fact</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                       <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extrudes a 2d surface mesh with bathymetry data defined in a 2d field.</span>

<span class="sd">    Generates a uniform terrain following mesh.</span>

<span class="sd">    :arg mesh2d: 2D mesh</span>
<span class="sd">    :arg n_layers: number of vertical layers</span>
<span class="sd">    :arg bathymetry: 2D :class:`Function` of the bathymetry</span>
<span class="sd">        (the depth of the domain; positive downwards)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">ExtrudedMesh</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="n">layers</span><span class="o">=</span><span class="n">n_layers</span><span class="p">,</span> <span class="n">layer_height</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n_layers</span><span class="p">)</span>

    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span>
    <span class="n">fs_3d</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">fs_2d</span> <span class="o">=</span> <span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">new_coordinates</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_3d</span><span class="p">)</span>

    <span class="n">z_stretch_func</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_2d</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z_stretch_fact</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">z_stretch_fact</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span> <span class="o">==</span> <span class="n">fs_2d</span>
        <span class="n">z_stretch_func</span> <span class="o">=</span> <span class="n">z_stretch_fact</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z_stretch_func</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">z_stretch_fact</span><span class="p">)</span>

    <span class="c1"># number of nodes in vertical direction</span>
    <span class="n">n_vert_nodes</span> <span class="o">=</span> <span class="n">fs_3d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span> <span class="o">/</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>

    <span class="n">min_depth_arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_layers</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span><span class="o">*</span><span class="mf">1e22</span>
    <span class="k">if</span> <span class="n">min_depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">min_depth</span><span class="p">):</span>
            <span class="n">min_depth_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
    <span class="n">min_depth_op2</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">min_depth_arr</span><span class="p">),</span> <span class="n">min_depth_arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;min_depth&#39;</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        void my_kernel(double *new_coords, double *old_coords, double *bath2d, double *z_stretch, int *idx, double *min_depth) {</span>
<span class="s2">            for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                double s_fact = z_stretch[d];</span>
<span class="s2">                for ( int e = 0; e &lt; </span><span class="si">%(v_nodes)d</span><span class="s2">; e++ ) {</span>
<span class="s2">                    new_coords[3*(idx[d]+e) + 0] = old_coords[3*(idx[d]+e) + 0];</span>
<span class="s2">                    new_coords[3*(idx[d]+e) + 1] = old_coords[3*(idx[d]+e) + 1];</span>
<span class="s2">                    double sigma = 1.0 - old_coords[3*(idx[d]+e) + 2]; // top 0, bot 1</span>
<span class="s2">                    double new_z = -bath2d[d] * pow(sigma, s_fact) ;</span>
<span class="s2">                    int layer = fmin(fmax(round(sigma*(</span><span class="si">%(n_layers)d</span><span class="s2"> + 1) - 1.0), 0.0), </span><span class="si">%(n_layers)d</span><span class="s2">);</span>
<span class="s2">                    double max_z = -min_depth[layer];</span>
<span class="s2">                    new_z = fmax(new_z, max_z);</span>
<span class="s2">                    new_coords[3*(idx[d]+e) + 2] = new_z;</span>
<span class="s2">                }</span>
<span class="s2">            }</span>
<span class="s2">        }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">(),</span>
                <span class="s1">&#39;v_nodes&#39;</span><span class="p">:</span> <span class="n">n_vert_nodes</span><span class="p">,</span>
                <span class="s1">&#39;n_layers&#39;</span><span class="p">:</span> <span class="n">n_layers</span><span class="p">},</span>
        <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

    <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                 <span class="n">new_coordinates</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">coordinates</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">z_stretch_func</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                 <span class="n">min_depth_op2</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                 <span class="n">iterate</span><span class="o">=</span><span class="n">op2</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span>

    <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">new_coordinates</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mesh</span></div>


<div class="viewcode-block" id="comp_volume_2d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_volume_2d">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.comp_volume_2d&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">comp_volume_2d</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">bath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes volume of the 2D domain as an integral of the elevation field&quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">((</span><span class="n">eta</span><span class="o">+</span><span class="n">bath</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="comp_volume_3d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_volume_3d">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.comp_volume_3d&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">comp_volume_3d</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes volume of the 3D domain as an integral&quot;&quot;&quot;</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">ufl_domain</span><span class="p">())</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">one</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="comp_tracer_mass_2d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_tracer_mass_2d">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.comp_tracer_mass_2d&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">comp_tracer_mass_2d</span><span class="p">(</span><span class="n">scalar_func</span><span class="p">,</span> <span class="n">total_depth</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes total tracer mass in the 2D domain</span>
<span class="sd">    :arg scalar_func: depth-averaged scalar :class:`Function` to integrate</span>
<span class="sd">    :arg total_depth: scalar UFL expression (e.g. from get_total_depth())</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">scalar_func</span><span class="o">*</span><span class="n">total_depth</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="comp_tracer_mass_3d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_tracer_mass_3d">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.comp_tracer_mass_3d&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">comp_tracer_mass_3d</span><span class="p">(</span><span class="n">scalar_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes total tracer mass in the 3D domain</span>

<span class="sd">    :arg scalar_func: scalar :class:`Function` to integrate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">scalar_func</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="get_zcoord_from_mesh"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_zcoord_from_mesh">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_zcoord_from_mesh&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_zcoord_from_mesh</span><span class="p">(</span><span class="n">zcoord</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates z coordinates from the 3D mesh</span>

<span class="sd">    :arg zcoord: scalar :class:`Function` where coordinates will be stored</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO coordinates should probably be interpolated instead</span>
    <span class="k">if</span> <span class="n">solver_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
    <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">tri</span><span class="o">*</span><span class="n">test</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">test</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">l</span><span class="p">,</span> <span class="n">zcoord</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zcoord</span></div>


<div class="viewcode-block" id="compute_baroclinic_head"><a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_baroclinic_head">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.compute_baroclinic_head&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">compute_baroclinic_head</span><span class="p">(</span><span class="n">solver</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the baroclinic head :math:`r` from the density field</span>

<span class="sd">    .. math::</span>
<span class="sd">        r = \frac{1}{\rho_0} \int_{z}^\eta  \rho&#39; d\zeta.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;density_solve&#39;</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">density_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;rho_integral&#39;</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">rho_integrator</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">baroc_head_3d</span> <span class="o">*=</span> <span class="o">-</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0_inv&#39;</span><span class="p">]</span>
    <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;int_pg_solve&#39;</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">int_pg_calculator</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>


<div class="viewcode-block" id="extend_function_to_3d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.extend_function_to_3d">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.extend_function_to_3d&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extend_function_to_3d</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">mesh_extruded</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a 3D view of a 2D :class:`Function` on the extruded domain.</span>

<span class="sd">    The 3D function resides in V x R function space, where V is the function</span>
<span class="sd">    space of the source function. The 3D function shares the data of the 2D</span>
<span class="sd">    function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">fs</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">geometric_dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Function must be in 2D space&#39;</span>
    <span class="n">ufl_elem</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span>
    <span class="n">family</span> <span class="o">=</span> <span class="n">ufl_elem</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
    <span class="n">degree</span> <span class="o">=</span> <span class="n">ufl_elem</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_elem</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">VectorElement</span><span class="p">):</span>
        <span class="c1"># vector function space</span>
        <span class="n">fs_extended</span> <span class="o">=</span> <span class="n">get_functionspace</span><span class="p">(</span><span class="n">mesh_extruded</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fs_extended</span> <span class="o">=</span> <span class="n">get_functionspace</span><span class="p">(</span><span class="n">mesh_extruded</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">func_extended</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_extended</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
    <span class="n">func_extended</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func_extended</span></div>


<div class="viewcode-block" id="ExtrudedFunction"><a class="viewcode-back" href="../../thetis.html#thetis.utility.ExtrudedFunction">[docs]</a><span class="k">class</span> <span class="nc">ExtrudedFunction</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A 2D :class:`Function` that provides a 3D view on the extruded domain.</span>

<span class="sd">    The 3D function can be accessed as `ExtrudedFunction.view_3d`.</span>
<span class="sd">    The 3D function resides in V x R function space, where V is the function</span>
<span class="sd">    space of the source function. The 3D function shares the data of the 2D</span>
<span class="sd">    function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">mesh_3d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a 2D :class:`Function` with a 3D view on extruded mesh.</span>

<span class="sd">        :arg mesh_3d: Extruded 3D mesh where the function will be extended to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create the 2d function</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mesh_3d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">view_3d</span> <span class="o">=</span> <span class="n">extend_function_to_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_3d</span><span class="p">)</span></div>


<div class="viewcode-block" id="SubdomainProjector"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SubdomainProjector">[docs]</a><span class="k">class</span> <span class="nc">SubdomainProjector</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Projector that projects the restriction of an expression to the specified subdomain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v_out</span><span class="p">,</span> <span class="n">subdomain_id</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constant_jacobian</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Function</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only project UFL expression or Functions not &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_out</span> <span class="o">=</span> <span class="n">v_out</span>

        <span class="n">V</span> <span class="o">=</span> <span class="n">v_out</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">subdomain_id</span><span class="p">)</span>

        <span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">v_out</span><span class="p">,</span>
                                           <span class="n">constant_jacobian</span><span class="o">=</span><span class="n">constant_jacobian</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">solver_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">,</span> <span class="s2">&quot;cg&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span>
                                              <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="SubdomainProjector.project"><a class="viewcode-back" href="../../thetis.html#thetis.utility.SubdomainProjector.project">[docs]</a>    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.SubdomainProjector.project&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the projection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="compute_elem_height"><a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_elem_height">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.compute_elem_height&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">compute_elem_height</span><span class="p">(</span><span class="n">zcoord</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the element height on an extruded mesh.</span>

<span class="sd">    :arg zcoord: field that contains the z coordinates of the mesh</span>
<span class="sd">    :type zcoord: :class:`Function`</span>
<span class="sd">    :arg output: field where element height is stored</span>
<span class="sd">    :type output: :class:`Function`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fs_in</span> <span class="o">=</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">fs_out</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

    <span class="n">iterate</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">ALL</span>

    <span class="c1"># NOTE height maybe &lt;0 if mesh was extruded like that</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        void my_kernel(double *func, double *zcoord) {</span>
<span class="s2">            for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">/2; d++ ) {</span>
<span class="s2">                for ( int c = 0; c &lt; </span><span class="si">%(func_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                    double dz = fabs(zcoord[</span><span class="si">%(func_dim)d</span><span class="s2">*(2*d+1) + c] - zcoord[</span><span class="si">%(func_dim)d</span><span class="s2">*2*d + c]);</span>
<span class="s2">                    func[</span><span class="si">%(output_dim)d</span><span class="s2">*2*d + c] = dz;</span>
<span class="s2">                    func[</span><span class="si">%(output_dim)d</span><span class="s2">*(2*d+1) + c] = dz;</span>
<span class="s2">                }</span>
<span class="s2">            }</span>
<span class="s2">        }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span><span class="o">.</span><span class="n">arity</span><span class="p">,</span>
                <span class="s1">&#39;func_dim&#39;</span><span class="p">:</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                <span class="s1">&#39;output_dim&#39;</span><span class="p">:</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span><span class="p">},</span>
        <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>
    <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span>
        <span class="n">kernel</span><span class="p">,</span> <span class="n">fs_out</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
        <span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">fs_out</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
        <span class="n">zcoord</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_in</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
        <span class="n">iterate</span><span class="o">=</span><span class="n">iterate</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="get_horizontal_elem_size_2d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_horizontal_elem_size_2d">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_horizontal_elem_size_2d&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_horizontal_elem_size_2d</span><span class="p">(</span><span class="n">sol2d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes horizontal element size from the 2D mesh</span>

<span class="sd">    :arg sol2d: 2D :class:`Function` where result is stored</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p1_2d</span> <span class="o">=</span> <span class="n">sol2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">p1_2d</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">p1_2d</span><span class="p">)</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">p1_2d</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">tri</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">CellVolume</span><span class="p">(</span><span class="n">mesh</span><span class="p">)))</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ksponly&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;cg&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;bjacobi&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sub_pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ilu&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">l</span><span class="p">,</span> <span class="n">sol2d</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_facet_areas"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_facet_areas">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_facet_areas&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_facet_areas</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute area of each facet of `mesh`. The facet areas are stored as a HDiv trace field.</span>

<span class="sd">    NOTES:</span>
<span class="sd">      * In the 2D case, this gives edge lengths.</span>
<span class="sd">      * The plus sign is arbitrary and could equally well be chosen as minus.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">HDivTrace</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;HDiv Trace&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">HDivTrace</span><span class="p">),</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">HDivTrace</span><span class="p">)</span>
    <span class="n">facet_areas</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">HDivTrace</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Facet areas&quot;</span><span class="p">)</span>
    <span class="n">mass_term</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">dS</span> <span class="o">+</span> <span class="n">v</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">ds</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">FacetArea</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">*</span><span class="n">dS</span> <span class="o">+</span> <span class="n">v</span><span class="o">*</span><span class="n">FacetArea</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;mat_type&quot;</span><span class="p">:</span> <span class="s2">&quot;matfree&quot;</span><span class="p">,</span>
        <span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ksponly&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;jacobi&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">mass_term</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">facet_areas</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">facet_areas</span></div>


<div class="viewcode-block" id="get_minimum_angles_2d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_minimum_angles_2d">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_minimum_angles_2d&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_minimum_angles_2d</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the minimum angle in each element of a triangular mesh, `mesh2d`, using the</span>
<span class="sd">    cosine rule. The minimum angles are outputted as a P0 field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">topological_dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">()</span> <span class="o">==</span> <span class="n">ufl</span><span class="o">.</span><span class="n">triangle</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Minimum angle only currently implemented for triangles.&quot;</span><span class="p">)</span>
    <span class="n">edge_lengths</span> <span class="o">=</span> <span class="n">get_facet_areas</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">)</span>
    <span class="n">min_angles</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">par_loop</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;for (int i=0; i&lt;angle.dofs; i++) {</span>

<span class="s2">                  double min_edge = edges[0];</span>
<span class="s2">                  int min_index = 0;</span>

<span class="s2">                  for (int j=1; j&lt;3; j++){</span>
<span class="s2">                    if (edges[j] &lt; min_edge) {</span>
<span class="s2">                      min_edge = edges[j];</span>
<span class="s2">                      min_index = j;</span>
<span class="s2">                    }</span>
<span class="s2">                  }</span>

<span class="s2">                  double numerator = 0.0;</span>
<span class="s2">                  double denominator = 2.0;</span>

<span class="s2">                  for (int j=0; j&lt;3; j++){</span>
<span class="s2">                    if (j == min_index) {</span>
<span class="s2">                      numerator -= edges[j]*edges[j];</span>
<span class="s2">                    } else {</span>
<span class="s2">                      numerator += edges[j]*edges[j];</span>
<span class="s2">                      denominator *= edges[j];</span>
<span class="s2">                    }</span>
<span class="s2">                  }</span>
<span class="s2">                  angle[0] = acos(numerator/denominator);</span>
<span class="s2">                }&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">edge_lengths</span><span class="p">,</span> <span class="n">READ</span><span class="p">),</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">min_angles</span><span class="p">,</span> <span class="n">RW</span><span class="p">)})</span>
    <span class="k">return</span> <span class="n">min_angles</span></div>


<div class="viewcode-block" id="get_cell_widths_2d"><a class="viewcode-back" href="../../thetis.html#thetis.utility.get_cell_widths_2d">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_cell_widths_2d&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_cell_widths_2d</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute widths of mesh elements in each coordinate direction as the maximum distance</span>
<span class="sd">    between components of vertex coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">topological_dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">()</span> <span class="o">==</span> <span class="n">ufl</span><span class="o">.</span><span class="n">triangle</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cell widths only currently implemented for triangles.&quot;</span><span class="p">)</span>
    <span class="n">cell_widths</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
    <span class="n">par_loop</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;for (int i=0; i&lt;coords.dofs; i++) {</span>
<span class="s2">                  widths[0] = fmax(widths[0], fabs(coords[2*i] - coords[(2*i+2)%6]));</span>
<span class="s2">                  widths[1] = fmax(widths[1], fabs(coords[2*i+1] - coords[(2*i+3)%6]));</span>
<span class="s2">                }&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;coords&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">mesh2d</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">READ</span><span class="p">),</span> <span class="s1">&#39;widths&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">cell_widths</span><span class="p">,</span> <span class="n">RW</span><span class="p">)})</span>
    <span class="k">return</span> <span class="n">cell_widths</span></div>


<div class="viewcode-block" id="anisotropic_cell_size"><a class="viewcode-back" href="../../thetis.html#thetis.utility.anisotropic_cell_size">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.anisotropic_cell_size&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">anisotropic_cell_size</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Measure of cell size for anisotropic meshes, as described in</span>
<span class="sd">    Micheletti et al. (2003).</span>

<span class="sd">    This is used in the SUPG formulation for the 2D tracer model.</span>

<span class="sd">    Micheletti, Perotto and Picasso (2003). Stabilized finite</span>
<span class="sd">    elements on anisotropic meshes: a priori error estimates for</span>
<span class="sd">    the advection-diffusion and the Stokes problems. SIAM Journal</span>
<span class="sd">    on Numerical Analysis 41.3: 1131-1162.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">firedrake.slate.slac.compiler</span> <span class="kn">import</span> <span class="n">PETSC_ARCH</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">PETSC_ARCH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;PETSC_DIR&#39;</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;PETSC_ARCH&#39;</span><span class="p">))</span>
    <span class="n">include_dir</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/include/eigen3&quot;</span> <span class="o">%</span> <span class="n">PETSC_ARCH</span><span class="p">]</span>

    <span class="c1"># Compute cell Jacobian</span>
    <span class="n">P0_ten</span> <span class="o">=</span> <span class="n">TensorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P0_ten</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cell Jacobian&quot;</span><span class="p">)</span>
    <span class="n">J</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Jacobian</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>

    <span class="c1"># Compute minimum eigenvalue</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">min_evalue</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Minimum eigenvalue&quot;</span><span class="p">)</span>
    <span class="n">kernel_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#include &lt;Eigen/Dense&gt;</span>

<span class="s2">using namespace Eigen;</span>

<span class="s2">void eigmin(double minEval[1], const double * J_) {</span>

<span class="s2">  // Map input onto an Eigen object</span>
<span class="s2">  Map&lt;Matrix&lt;double, 2, 2, RowMajor&gt; &gt; J((double *)J_);</span>

<span class="s2">  // Compute J^T * J</span>
<span class="s2">  Matrix&lt;double, 2, 2, RowMajor&gt; A = J.transpose()*J;</span>

<span class="s2">  // Solve eigenvalue problem</span>
<span class="s2">  SelfAdjointEigenSolver&lt;Matrix&lt;double, 2, 2, RowMajor&gt;&gt; eigensolver(A);</span>
<span class="s2">  Vector2d D = eigensolver.eigenvalues();</span>

<span class="s2">  // Take the square root</span>
<span class="s2">  double lambda1 = sqrt(fabs(D(0)));</span>
<span class="s2">  double lambda2 = sqrt(fabs(D(1)));</span>

<span class="s2">  // Select minimum eigenvalue in modulus</span>
<span class="s2">  minEval[0] = fmin(lambda1, lambda2);</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="n">kernel_str</span><span class="p">,</span> <span class="s1">&#39;eigmin&#39;</span><span class="p">,</span> <span class="n">cpp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_dirs</span><span class="o">=</span><span class="n">include_dir</span><span class="p">)</span>
    <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">P0_ten</span><span class="o">.</span><span class="n">node_set</span><span class="p">,</span> <span class="n">min_evalue</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">RW</span><span class="p">),</span> <span class="n">J</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">min_evalue</span></div>


<div class="viewcode-block" id="beta_plane_coriolis_params"><a class="viewcode-back" href="../../thetis.html#thetis.utility.beta_plane_coriolis_params">[docs]</a><span class="k">def</span> <span class="nf">beta_plane_coriolis_params</span><span class="p">(</span><span class="n">latitude</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes beta plane parameters :math:`f_0,\beta` based on latitude</span>

<span class="sd">    :arg float latitude: latitude in degrees</span>
<span class="sd">    :return: f_0, beta</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mf">7.2921150e-5</span>  <span class="c1"># rad/s Earth rotation rate</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mf">6371.e3</span>  <span class="c1"># Earth radius</span>
    <span class="c1"># Coriolis parameter f = 2 Omega sin(alpha)</span>
    <span class="c1"># Beta plane approximation f_beta = f_0 + Beta y</span>
    <span class="c1"># f_0 = 2 Omega sin(alpha_0)</span>
    <span class="c1"># Beta = df/dy|_{alpha=alpha_0}</span>
    <span class="c1">#      = (df/dalpha*dalpha/dy)_{alpha=alpha_0}</span>
    <span class="c1">#      = 2 Omega cos(alpha_0) /R</span>
    <span class="n">alpha_0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">latitude</span><span class="o">/</span><span class="mf">360.0</span>
    <span class="n">f_0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha_0</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_0</span><span class="p">)</span><span class="o">/</span><span class="n">r</span>
    <span class="k">return</span> <span class="n">f_0</span><span class="p">,</span> <span class="n">beta</span></div>


<div class="viewcode-block" id="beta_plane_coriolis_function"><a class="viewcode-back" href="../../thetis.html#thetis.utility.beta_plane_coriolis_function">[docs]</a><span class="k">def</span> <span class="nf">beta_plane_coriolis_function</span><span class="p">(</span><span class="n">latitude</span><span class="p">,</span> <span class="n">out_function</span><span class="p">,</span> <span class="n">y_offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolates beta plane Coriolis function to a field</span>

<span class="sd">    :arg float latitude: latitude in degrees</span>
<span class="sd">    :arg out_function: :class:`Function` where to interpolate</span>
<span class="sd">    :kwarg float y_offset: offset (y - y_0) used in Beta-plane approximation.</span>
<span class="sd">        A constant in mesh coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE assumes that mesh y coordinate spans [-L_y, L_y]</span>
    <span class="n">f0</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">beta_plane_coriolis_params</span><span class="p">(</span><span class="n">latitude</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">out_function</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">())</span>
    <span class="n">out_function</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">f0</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_offset</span><span class="p">))</span></div>


<div class="viewcode-block" id="tensor_jump"><a class="viewcode-back" href="../../thetis.html#thetis.utility.tensor_jump">[docs]</a><span class="k">def</span> <span class="nf">tensor_jump</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jump term for vector functions based on the tensor product</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{jump}(\mathbf{u}, \mathbf{n}) = (\mathbf{u}^+ \mathbf{n}^+) +</span>
<span class="sd">        (\mathbf{u}^- \mathbf{n}^-)</span>

<span class="sd">    This is the discrete equivalent of grad(u) as opposed to the</span>
<span class="sd">    vectorial UFL jump operator :meth:`ufl.jump` which represents div(u).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">outer</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">),</span> <span class="n">n</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="n">outer</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">),</span> <span class="n">n</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="compute_boundary_length"><a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_boundary_length">[docs]</a><span class="k">def</span> <span class="nf">compute_boundary_length</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the length of the boundary segments in given 2d mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">get_functionspace</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">boundary_markers</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mesh2d</span><span class="o">.</span><span class="n">exterior_facets</span><span class="o">.</span><span class="n">unique_markers</span><span class="p">)</span>
    <span class="n">boundary_len</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundary_markers</span><span class="p">:</span>
        <span class="n">ds_restricted</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">one_func</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">boundary_len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">one_func</span> <span class="o">*</span> <span class="n">ds_restricted</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">boundary_len</span></div>


<div class="viewcode-block" id="select_and_move_detectors"><a class="viewcode-back" href="../../thetis.html#thetis.utility.select_and_move_detectors">[docs]</a><span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.select_and_move_detectors&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">select_and_move_detectors</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">detector_locations</span><span class="p">,</span> <span class="n">detector_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">maximum_distance</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Select those detectors that are within the domain and/or move them to</span>
<span class="sd">    the nearest cell centre within the domain</span>

<span class="sd">    :arg mesh: Defines the domain in which detectors are to be located</span>
<span class="sd">    :arg detector_locations: List of x, y locations</span>
<span class="sd">    :arg detector_names: List of detector names (optional). If provided, a list</span>
<span class="sd">       of selected locations and a list of selected detector names are returned,</span>
<span class="sd">       otherwise only a list of selected locations is returned</span>
<span class="sd">    :arg maximum_distance: Detectors whose initial locations is outside the domain,</span>
<span class="sd">      but for which the nearest cell centre is within the specified distance, are</span>
<span class="sd">      moved to this location. By default a maximum distance of 0.0 is used, i.e</span>
<span class="sd">      no detectors are moved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># auxilary function to test whether we can interpolate it in the given locations</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">P0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">VP0</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span>
    <span class="n">loc_const</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">p0xy</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">VP0</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>

    <span class="c1"># comparison operator that sorts on first entry first, etc.</span>
    <span class="k">def</span> <span class="nf">min_lexsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">datatype</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">yi</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="n">yi</span> <span class="o">&lt;</span> <span class="n">xi</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y</span>
        <span class="c1"># all entries the same:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">min_lexsort_op</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">Op</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">min_lexsort</span><span class="p">,</span> <span class="n">commute</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">move_to_nearest_cell_center</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
        <span class="n">loc_const</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="n">dist</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">xy</span><span class="o">-</span><span class="n">loc_const</span><span class="p">,</span> <span class="n">xy</span><span class="o">-</span><span class="n">loc_const</span><span class="p">))</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="c1"># smallest distance to a cell centre location on this process:</span>
        <span class="n">local_loc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p0xy</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="n">local_dist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="c1"># select the smallest distance on all processes. If some distances are equal, pick a unique loc. based on lexsort</span>
        <span class="n">global_dist_loc</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">([</span><span class="n">local_dist</span><span class="p">]</span><span class="o">+</span><span class="n">local_loc</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">min_lexsort_op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">global_dist_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">global_dist_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">accepted_locations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">accepted_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">detector_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">detector_names</span>
    <span class="k">for</span> <span class="n">location</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">PointNotInDomainError</span><span class="p">:</span>
            <span class="n">moved_dist</span><span class="p">,</span> <span class="n">location</span> <span class="o">=</span> <span class="n">move_to_nearest_cell_center</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">moved_dist</span> <span class="o">&gt;</span> <span class="n">maximum_distance</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="n">accepted_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="n">accepted_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">min_lexsort_op</span><span class="o">.</span><span class="n">Free</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">detector_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">accepted_locations</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">accepted_locations</span><span class="p">,</span> <span class="n">accepted_names</span></div>


<div class="viewcode-block" id="DepthExpression"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthExpression">[docs]</a><span class="k">class</span> <span class="nc">DepthExpression</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct expression for depth depending on options</span>

<span class="sd">    If `not use_nonlinear_equations`, then the depth is simply the bathymetry:</span>

<span class="sd">  ..math::</span>
<span class="sd">        H = h</span>

<span class="sd">    Otherwise we include the free surface elevation:</span>

<span class="sd">  ..math::</span>
<span class="sd">        H = h + \eta</span>

<span class="sd">    and if `use_wetting_and_drying`, includes a bathymetry displacement term</span>
<span class="sd">    to ensure a positive depth (see Karna et al. 2011):</span>

<span class="sd">  ..math::</span>
<span class="sd">        H = h + f(h+\eta) + \eta</span>

<span class="sd">    where</span>

<span class="sd">  ..math::</span>
<span class="sd">        f(h+\eta) = (\sqrt{(h+\eta)^2 +\alpha^2} - (h+\eta))/2</span>

<span class="sd">    This introduces a wetting-drying parameter :math:`\alpha`, with dimensions</span>
<span class="sd">    of length. The value for :math:`\alpha` is specified by</span>
<span class="sd">    :attr:`.ModelOptions.wetting_and_drying_alpha`, in units of meters. The</span>
<span class="sd">    default value is 0.5, but the appropriate value is problem specific and</span>
<span class="sd">    should be set by the user.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bathymetry_2d</span><span class="p">,</span> <span class="n">use_nonlinear_equations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">use_wetting_and_drying</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wetting_and_drying_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_2d</span> <span class="o">=</span> <span class="n">bathymetry_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_nonlinear_equations</span> <span class="o">=</span> <span class="n">use_nonlinear_equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_wetting_and_drying</span> <span class="o">=</span> <span class="n">use_wetting_and_drying</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wetting_and_drying_alpha</span> <span class="o">=</span> <span class="n">wetting_and_drying_alpha</span>

<div class="viewcode-block" id="DepthExpression.wd_bathymetry_displacement"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthExpression.wd_bathymetry_displacement">[docs]</a>    <span class="k">def</span> <span class="nf">wd_bathymetry_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns wetting and drying bathymetry displacement as described in:</span>
<span class="sd">        Karna et al.,  2011.</span>
<span class="sd">        :arg eta: current elevation as UFL expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_wetting_and_drying</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_2d</span> <span class="o">+</span> <span class="n">eta</span>
            <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">H</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">wetting_and_drying_alpha</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">H</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="DepthExpression.get_total_depth"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthExpression.get_total_depth">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns total water column depth based on options</span>
<span class="sd">        :arg eta: current elevation as UFL expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_nonlinear_equations</span><span class="p">:</span>
            <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_2d</span> <span class="o">+</span> <span class="n">eta</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">wd_bathymetry_displacement</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_2d</span>
        <span class="k">return</span> <span class="n">total_h</span></div></div>


<div class="viewcode-block" id="DepthIntegratedPoissonSolver"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthIntegratedPoissonSolver">[docs]</a><span class="k">class</span> <span class="nc">DepthIntegratedPoissonSolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct solvers for Poisson equation and updating velocities</span>

<span class="sd">    Poisson equation is related to 2d NH SWE system</span>

<span class="sd">    Non-hydrostatic pressure :math:`q` is obtained from the generic form of equation</span>

<span class="sd">    .. math::</span>
<span class="sd">        \nabla \cdot \nabla q^{n+1/2} + A \cdot \nabla q^{n+1/2} + B q^{n+1/2} + C = 0</span>

<span class="sd">    The parameter terms A, B and C are defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        A = \frac{\nabla (\eta^* - d)}{H^*}</span>
<span class="sd">        B = \nabla A - \frac{4}{(H^*)^2}</span>
<span class="sd">        C = -2 \frac{\rho_0}{\Delta t} ( \nabla \cdot \bar{\textbf{u}}^* + 2 \frac{\bar{w} - w_b}{H^*} )</span>

<span class="sd">    where the :math:`H = \eta + d` denotes the water depth</span>
<span class="sd">    and the superscript star symbol represents the intermediate level of terms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.DepthIntegratedPoissonSolver.__init__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_2d</span><span class="p">,</span> <span class="n">uv_2d</span><span class="p">,</span> <span class="n">w_2d</span><span class="p">,</span> <span class="n">elev_2d</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">bnd_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">solver_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;snes_type&#39;</span><span class="p">:</span> <span class="s1">&#39;ksponly&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;ksp_type&#39;</span><span class="p">:</span> <span class="s1">&#39;preonly&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;mat_type&#39;</span><span class="p">:</span> <span class="s1">&#39;aij&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;pc_type&#39;</span><span class="p">:</span> <span class="s1">&#39;lu&#39;</span><span class="p">}</span>
        <span class="n">rho_0</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span> <span class="o">=</span> <span class="n">q_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span> <span class="o">=</span> <span class="n">uv_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span> <span class="o">=</span> <span class="n">w_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elev_2d</span> <span class="o">=</span> <span class="n">elev_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bnd_functions</span> <span class="o">=</span> <span class="n">bnd_functions</span>

        <span class="n">fs_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">test_q</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs_q</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">fs_q</span><span class="o">.</span><span class="n">mesh</span><span class="p">())</span>
        <span class="n">boundary_markers</span> <span class="o">=</span> <span class="n">fs_q</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">exterior_facets</span><span class="o">.</span><span class="n">unique_markers</span>

        <span class="n">bath_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">bathymetry_2d</span>
        <span class="n">h_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elev_2d</span><span class="p">)</span>
        <span class="n">w_b</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">bath_2d</span><span class="p">))</span>  <span class="c1"># TODO account for bed movement</span>

        <span class="c1"># weak form of `div(grad(q^{n+1/2}))`</span>
        <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">test_q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
        <span class="c1"># weak form of `dot(grad(self.elev_2d - bath_2d)/h_star, grad(q^{n+1/2}))`</span>
        <span class="n">grad_hori</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elev_2d</span> <span class="o">-</span> <span class="n">bath_2d</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad_hori</span><span class="o">/</span><span class="n">h_star</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">))</span><span class="o">*</span><span class="n">test_q</span><span class="o">*</span><span class="n">dx</span>
        <span class="c1"># weak form of `q^{n+1/2}*div(grad(self.elev_2d - bath_2d))/h_star`</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">*</span><span class="n">test_q</span><span class="o">/</span><span class="n">h_star</span><span class="p">),</span> <span class="n">grad_hori</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="c1"># weak form of `-q^{n+1/2}*(dot(grad(self.elev_2d - bath_2d), grad(h_star)) + 4)/h_star**2`</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">grad_hori</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">h_star</span><span class="p">))</span> <span class="o">+</span> <span class="mf">4.</span><span class="p">)</span><span class="o">/</span><span class="n">h_star</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">*</span><span class="n">test_q</span><span class="o">*</span><span class="n">dx</span>
        <span class="c1"># weak form of `-2.*rho_0/self.dt*(div(self.uv_2d) + (self.w_2d - w_b)/(0.5*h_star))`</span>
        <span class="n">const</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">rho_0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="n">const</span><span class="o">*</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">test_q</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span> <span class="o">-</span> <span class="n">w_b</span><span class="p">)</span><span class="o">/</span><span class="n">h_star</span><span class="o">*</span><span class="n">test_q</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>

        <span class="c1"># boundary conditions</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="n">boundary_markers</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bnd_functions</span><span class="p">[</span><span class="s1">&#39;shallow_water&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
            <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># e.g. inlet flow, TODO be more precise</span>
                <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">fs_q</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">))</span>
                <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">*</span><span class="n">test_q</span><span class="o">/</span><span class="n">h_star</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad_hori</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">const</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">test_q</span><span class="o">*</span><span class="n">ds_bnd</span>

        <span class="n">prob_q</span> <span class="o">=</span> <span class="n">NonlinearVariationalProblem</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_q</span> <span class="o">=</span> <span class="n">NonlinearVariationalSolver</span><span class="p">(</span>
            <span class="n">prob_q</span><span class="p">,</span>
            <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">,</span>
            <span class="n">options_prefix</span><span class="o">=</span><span class="s1">&#39;poisson_solver&#39;</span>
        <span class="p">)</span>
        <span class="c1"># horizontal velocity updater</span>
        <span class="n">fs_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">tri_u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs_u</span><span class="p">)</span>
        <span class="n">test_u</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs_u</span><span class="p">)</span>
        <span class="n">a_u</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri_u</span><span class="p">,</span> <span class="n">test_u</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">l_u</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="n">rho_0</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">)</span> <span class="o">+</span> <span class="n">grad_hori</span><span class="o">/</span><span class="n">h_star</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">),</span> <span class="n">test_u</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">prob_u</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a_u</span><span class="p">,</span> <span class="n">l_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_u</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">prob_u</span><span class="p">)</span>
        <span class="c1"># vertical velocity updater</span>
        <span class="n">fs_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">tri_w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs_w</span><span class="p">)</span>
        <span class="n">test_w</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs_w</span><span class="p">)</span>
        <span class="n">a_w</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri_w</span><span class="p">,</span> <span class="n">test_w</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">l_w</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="n">rho_0</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">/</span><span class="n">h_star</span><span class="p">),</span> <span class="n">test_w</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">prob_w</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a_w</span><span class="p">,</span> <span class="n">l_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span><span class="p">)</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;cg&quot;</span><span class="p">,</span>
            <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;bjacobi&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sub_pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ilu&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_w</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">prob_w</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span>

<div class="viewcode-block" id="DepthIntegratedPoissonSolver.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthIntegratedPoissonSolver.solve">[docs]</a>    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.DepthIntegratedPoissonSolver.solve&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solve_w</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># solve non-hydrostatic pressure q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_q</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="c1"># update horizontal velocity uv_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_u</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="c1"># update vertical velocity w_2d</span>
        <span class="k">if</span> <span class="n">solve_w</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_w</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2021, Tuomas Krn et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>