<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>thetis.utility &#8212; Thetis 0+untagged.2082.gf1a0bbb documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/thetis.css?v=0f3339d6" />
    <script src="../../_static/documentation_options.js?v=ccd1159c"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<!-- <link rel="stylesheet" href="../../_static/featured.css"> -->


<link rel="shortcut icon" href="../../_static/icon_thetis.ico" />


  </head><body>
<div class="wrapper">
  <a href="../../index.html"><img src="../../_static/banner.jpg" height="180px" alt="Thetis Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
        <li class="page_item"><a href="../../documentation.html" title="Thetis documentation">Documentation</a></li>
        <li class="page_item"><a href="../../download.html" title="Install Thetis">Download</a></li>
        <li class="page_item"><a href="../../team.html" title="Development team">Team</a></li>
        <li class="page_item"><a href="../../publications.html" title="Publications">Publications</a></li>
        <li class="page_item"><a href="../../funding.html" title="Our financial supporters">Funding</a></li>
        <li class="page_item"><a href="../../contact.html" title="Getting in touch">Contact</a></li>
        <li class="page_item"><a href="https://github.com/thetisproject/thetis" title="Thetis source on GitHub">GitHub</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="_modules/thetis/utility">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for thetis.utility</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utility functions and classes for 2D and 3D ocean models</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">namedtuple</span>  <span class="c1"># NOQA</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ufl</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">firedrake</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">firedrake.petsc</span><span class="w"> </span><span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyop2.profiling</span><span class="w"> </span><span class="kn">import</span> <span class="n">timed_stage</span>  <span class="c1"># NOQA</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyadjoint.tape</span><span class="w"> </span><span class="kn">import</span> <span class="n">no_annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.field_defs</span><span class="w"> </span><span class="kn">import</span> <span class="n">field_metadata</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.log</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.physical_constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">physical_constants</span>

<span class="n">ds_surf</span> <span class="o">=</span> <span class="n">ds_t</span>
<span class="n">ds_bottom</span> <span class="o">=</span> <span class="n">ds_b</span>


<div class="viewcode-block" id="FrozenClass">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.FrozenClass">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FrozenClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class where creating a new attribute will raise an exception if</span>
<span class="sd">    :attr:`_isfrozen` is ``True``.</span>

<span class="sd">    :attr:`_unfreezedepth` allows for multiple applications of the</span>
<span class="sd">    ``unfrozen`` decorator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_isfrozen</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_unfreezedepth</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isfrozen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Adding new attribute &quot;</span><span class="si">{:}</span><span class="s1">&quot; to </span><span class="si">{:}</span><span class="s1"> class is forbidden&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FrozenClass</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>



<div class="viewcode-block" id="unfrozen">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.unfrozen">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unfrozen</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to temporarily unfreeze an object</span>
<span class="sd">    whilst one of its methods is being called.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isfrozen</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfreezedepth</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfreezedepth</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isfrozen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unfreezedepth</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>



<div class="viewcode-block" id="SumFunction">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.SumFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SumFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper class to keep track of sum of Coefficients.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize empty sum.</span>

<span class="sd">        get operation returns Constant(0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="SumFunction.add">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.SumFunction.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a coefficient to self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span></div>


<div class="viewcode-block" id="SumFunction.get_sum">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.SumFunction.get_sum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a sum of all added Coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff_list</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="AttrDict">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.AttrDict">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AttrDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary that provides both self[&#39;key&#39;] and self.key access to members.</span>

<span class="sd">    http://stackoverflow.com/questions/4984647/accessing-dict-keys-like-an-attribute-in-python</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;AttrDict requires python &gt;= 2.7.4 to avoid memory leaks&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="FieldDict">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.FieldDict">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FieldDict</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    AttrDict that checks that all added fields have proper meta data.</span>

<span class="sd">    Values can be either Function or Constant objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">firedrake.functionspaceimpl</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">MixedFunctionSpace</span><span class="p">,</span>
                                                     <span class="n">WithGeometry</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Value must be a Function or Constant object&#39;</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
            <span class="n">is_mixed</span> <span class="o">=</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">MixedFunctionSpace</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">WithGeometry</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">topological</span><span class="p">,</span> <span class="n">MixedFunctionSpace</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_mixed</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">field_metadata</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Trying to add a field &quot;</span><span class="si">{:}</span><span class="s1">&quot; that has no metadata. &#39;</span> \
                      <span class="s1">&#39;Add field_metadata entry to field_defs.py&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_functionname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set function.name to key to ensure consistent naming&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="n">value</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inputs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_functionname</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FieldDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inputs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_functionname</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FieldDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>



<div class="viewcode-block" id="domain_constant">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.domain_constant">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">domain_constant</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create constant over a domain</span>

<span class="sd">    Returns what used to be Constant(value, domain=mesh)&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">ufl_shape</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">TensorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c</span></div>



<div class="viewcode-block" id="get_functionspace">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.get_functionspace">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">h_family</span><span class="p">,</span> <span class="n">h_degree</span><span class="p">,</span> <span class="n">v_family</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">vector</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hdiv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v_variant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">cell_dim</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cell_dimension</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">cell_dim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="s1">&#39;Unsupported cell dimension&#39;</span>
    <span class="n">hdiv_families</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;RT&#39;</span><span class="p">,</span> <span class="s1">&#39;RTF&#39;</span><span class="p">,</span> <span class="s1">&#39;RTCF&#39;</span><span class="p">,</span> <span class="s1">&#39;RAVIART-THOMAS&#39;</span><span class="p">,</span>
        <span class="s1">&#39;BDM&#39;</span><span class="p">,</span> <span class="s1">&#39;BDMF&#39;</span><span class="p">,</span> <span class="s1">&#39;BDMCF&#39;</span><span class="p">,</span> <span class="s1">&#39;BREZZI-DOUGLAS-MARINI&#39;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">variant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">h_family</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="n">hdiv_families</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h_family</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RTCF&#39;</span><span class="p">,</span> <span class="s1">&#39;BDMCF&#39;</span><span class="p">]:</span>
                <span class="n">variant</span> <span class="o">=</span> <span class="s1">&#39;equispaced&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variant</span> <span class="o">=</span> <span class="s1">&#39;integral&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variant</span> <span class="o">=</span> <span class="s1">&#39;equispaced&#39;</span>
    <span class="k">if</span> <span class="n">v_variant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v_variant</span> <span class="o">=</span> <span class="s1">&#39;equispaced&#39;</span>
    <span class="k">if</span> <span class="n">cell_dim</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v_family</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v_family</span> <span class="o">=</span> <span class="n">h_family</span>
        <span class="k">if</span> <span class="n">v_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v_degree</span> <span class="o">=</span> <span class="n">h_degree</span>
        <span class="n">h_cell</span><span class="p">,</span> <span class="n">v_cell</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">()</span><span class="o">.</span><span class="n">sub_cells</span><span class="p">()</span>
        <span class="n">h_elt</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">h_family</span><span class="p">,</span> <span class="n">h_cell</span><span class="p">,</span> <span class="n">h_degree</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="n">variant</span><span class="p">)</span>
        <span class="n">v_elt</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">v_family</span><span class="p">,</span> <span class="n">v_cell</span><span class="p">,</span> <span class="n">v_degree</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="n">v_variant</span><span class="p">)</span>
        <span class="n">elt</span> <span class="o">=</span> <span class="n">TensorProductElement</span><span class="p">(</span><span class="n">h_elt</span><span class="p">,</span> <span class="n">v_elt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hdiv</span><span class="p">:</span>
            <span class="n">elt</span> <span class="o">=</span> <span class="n">HDiv</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">elt</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">h_family</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">(),</span> <span class="n">h_degree</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="n">variant</span><span class="p">)</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">vector</span> <span class="ow">and</span> <span class="n">tensor</span><span class="p">)</span>
    <span class="n">constructor</span> <span class="o">=</span> <span class="n">TensorFunctionSpace</span> <span class="k">if</span> <span class="n">tensor</span> <span class="k">else</span> <span class="n">VectorFunctionSpace</span> <span class="k">if</span> <span class="n">vector</span> <span class="k">else</span> <span class="n">FunctionSpace</span>
    <span class="k">return</span> <span class="n">constructor</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">elt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_extruded_base_element">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.get_extruded_base_element">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_extruded_base_element</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return UFL TensorProductElement of an extruded UFL element.</span>

<span class="sd">    In case of a non-extruded mesh, returns the element itself.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">,</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">HDivElement</span><span class="p">):</span>
        <span class="n">ufl_element</span> <span class="o">=</span> <span class="n">ufl_element</span><span class="o">.</span><span class="n">_element</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">,</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">MixedElement</span><span class="p">):</span>
        <span class="n">ufl_element</span> <span class="o">=</span> <span class="n">ufl_element</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">,</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">VectorElement</span><span class="p">):</span>
        <span class="n">ufl_element</span> <span class="o">=</span> <span class="n">ufl_element</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># take the first component</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">,</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">EnrichedElement</span><span class="p">):</span>
        <span class="n">ufl_element</span> <span class="o">=</span> <span class="n">ufl_element</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ufl_element</span></div>



<span class="n">ElementContinuity</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;ElementContinuity&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;horizontal&quot;</span><span class="p">,</span> <span class="s2">&quot;vertical&quot;</span><span class="p">])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A named tuple describing the continuity of an element in the horizontal/vertical direction.</span>

<span class="sd">The field value is one of &quot;cg&quot;, &quot;hdiv&quot;, or &quot;dg&quot;.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="element_continuity">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.element_continuity">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">element_continuity</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an :class:`ElementContinuity` instance with the</span>
<span class="sd">    continuity of a given element.</span>

<span class="sd">    :arg ufl_element: The UFL element to determine the continuity</span>
<span class="sd">        of.</span>
<span class="sd">    :returns: A new :class:`ElementContinuity` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">ufl_element</span>
    <span class="n">elem_types</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Discontinuous Lagrange&#39;</span><span class="p">:</span> <span class="s1">&#39;dg&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Lagrange&#39;</span><span class="p">:</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Raviart-Thomas&#39;</span><span class="p">:</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;RTCF&#39;</span><span class="p">:</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Brezzi-Douglas-Marini&#39;</span><span class="p">:</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;BDMCF&#39;</span><span class="p">:</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span>
        <span class="s1">&#39;DQ&#39;</span><span class="p">:</span> <span class="s1">&#39;dg&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">base_element</span> <span class="o">=</span> <span class="n">get_extruded_base_element</span><span class="p">(</span><span class="n">ufl_element</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">HDivElement</span><span class="p">):</span>
        <span class="n">horiz_type</span> <span class="o">=</span> <span class="s1">&#39;hdiv&#39;</span>
        <span class="n">vert_type</span> <span class="o">=</span> <span class="s1">&#39;hdiv&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_element</span><span class="p">,</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TensorProductElement</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">base_element</span><span class="o">.</span><span class="n">sub_elements</span>
        <span class="n">horiz_type</span> <span class="o">=</span> <span class="n">elem_types</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">family</span><span class="p">()]</span>
        <span class="n">vert_type</span> <span class="o">=</span> <span class="n">elem_types</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">family</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">horiz_type</span> <span class="o">=</span> <span class="n">elem_types</span><span class="p">[</span><span class="n">base_element</span><span class="o">.</span><span class="n">family</span><span class="p">()]</span>
        <span class="n">vert_type</span> <span class="o">=</span> <span class="n">horiz_type</span>
    <span class="k">return</span> <span class="n">ElementContinuity</span><span class="p">(</span><span class="n">horiz_type</span><span class="p">,</span> <span class="n">vert_type</span><span class="p">)</span></div>



<div class="viewcode-block" id="create_directory">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.create_directory">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_directory</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">COMM_WORLD</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a directory on disk</span>

<span class="sd">    Raises IOError if a file with the same name already exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;file with same name exists&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">path</span></div>



<div class="viewcode-block" id="read_mesh_from_checkpoint">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.read_mesh_from_checkpoint">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_mesh_from_checkpoint</span><span class="p">(</span><span class="n">filename_or_outputdir</span><span class="p">,</span> <span class="n">mesh_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read mesh from a hdf5 checkpoint file.</span>
<span class="sd">    :arg filename_or_outputdir: file name of the hdf5 checkpoint file,</span>
<span class="sd">       or the output directory used in the previous run that create the</span>
<span class="sd">       checkpoint. In the latter case the mesh will be read from the</span>
<span class="sd">       first file that&#39;s found in outputdir/hdf5/*.h5</span>

<span class="sd">    When loading fields from a checkpoint file in a run, the mesh used in that</span>
<span class="sd">    run needs to be read from that same checkpoint file.</span>

<span class="sd">    When multiple checkpoint files are used as model inputs which have</span>
<span class="sd">    been created in separate runs/scripts, make sure that only one of those</span>
<span class="sd">    scripts created the original mesh (by reading a .msh file or using a mesh</span>
<span class="sd">    creation utility like RectangleMesh) and all other script read their mesh</span>
<span class="sd">    from the checkpoint created by that first script.  For example, a</span>
<span class="sd">    preprocessing script might read in a .msh file and interpolate and smoothen</span>
<span class="sd">    the bathymetry on that mesh and write out the result in a checkpoint. A</span>
<span class="sd">    first Thetis run should read its mesh from that checkpoint, and may then</span>
<span class="sd">    save a series of hdf5 files.  A second Thetis run can then read in the mesh</span>
<span class="sd">    and bathymetry from the checkpoint of the preprocessing script, and call</span>
<span class="sd">    load_state() to pick up from the previous run.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">filename_or_outputdir</span><span class="p">):</span>
        <span class="c1"># grab the first outputdir/hdf5/*.h5 file we can find</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filename_or_outputdir</span><span class="p">,</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;*.h5&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">iglob</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No checkpoint files found in </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># assume we&#39;re being pointed to the hdf5 file directly</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename_or_outputdir</span>

    <span class="k">with</span> <span class="n">CheckpointFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mesh_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mesh_name</span> <span class="o">=</span> <span class="s1">&#39;firedrake_default&#39;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">mesh_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mesh</span></div>



<div class="viewcode-block" id="get_facet_mask">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.get_facet_mask">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_facet_mask&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_facet_mask</span><span class="p">(</span><span class="n">function_space</span><span class="p">,</span> <span class="n">facet</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the top/bottom nodes of extruded 3D elements.</span>

<span class="sd">    :arg function_space: Firedrake :class:`FunctionSpace` object</span>
<span class="sd">    :kwarg str facet: &#39;top&#39; or &#39;bottom&#39;</span>

<span class="sd">    .. note::</span>
<span class="sd">        The definition of top/bottom depends on the direction of the extrusion.</span>
<span class="sd">        Here we assume that the mesh has been extruded upwards (along positive</span>
<span class="sd">        z axis).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">finat.element_factory</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_element</span> <span class="k">as</span> <span class="n">create_finat_element</span>

    <span class="c1"># get base element</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">get_extruded_base_element</span><span class="p">(</span><span class="n">function_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">TensorProductElement</span><span class="p">),</span> \
        <span class="sa">f</span><span class="s1">&#39;function space must be defined on an extruded 3D mesh: </span><span class="si">{</span><span class="n">elem</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="c1"># figure out number of nodes in sub elements</span>
    <span class="n">h_elt</span><span class="p">,</span> <span class="n">v_elt</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">sub_elements</span>
    <span class="n">nb_nodes_h</span> <span class="o">=</span> <span class="n">create_finat_element</span><span class="p">(</span><span class="n">h_elt</span><span class="p">)</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>
    <span class="n">nb_nodes_v</span> <span class="o">=</span> <span class="n">create_finat_element</span><span class="p">(</span><span class="n">v_elt</span><span class="p">)</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>
    <span class="c1"># compute top/bottom facet indices</span>
    <span class="c1"># extruded dimension is the inner loop in index</span>
    <span class="c1"># on interval elements, the end points are the first two dofs</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">facet</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nb_nodes_h</span><span class="p">)</span><span class="o">*</span><span class="n">nb_nodes_v</span> <span class="o">+</span> <span class="n">offset</span>
    <span class="k">return</span> <span class="n">indices</span></div>



<div class="viewcode-block" id="extrude_mesh_sigma">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.extrude_mesh_sigma">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.extrude_mesh_sigma&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">extrude_mesh_sigma</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">,</span> <span class="n">bathymetry_2d</span><span class="p">,</span> <span class="n">z_stretch_fact</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                       <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extrudes a 2d surface mesh with bathymetry data defined in a 2d field.</span>

<span class="sd">    Generates a uniform terrain following mesh.</span>

<span class="sd">    :arg mesh2d: 2D mesh</span>
<span class="sd">    :arg n_layers: number of vertical layers</span>
<span class="sd">    :arg bathymetry: 2D :class:`Function` of the bathymetry</span>
<span class="sd">        (the depth of the domain; positive downwards)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">ExtrudedMesh</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="n">layers</span><span class="o">=</span><span class="n">n_layers</span><span class="p">,</span> <span class="n">layer_height</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n_layers</span><span class="p">)</span>

    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span>
    <span class="n">fs_3d</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">fs_2d</span> <span class="o">=</span> <span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">new_coordinates</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_3d</span><span class="p">)</span>

    <span class="n">z_stretch_func</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_2d</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z_stretch_fact</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">z_stretch_fact</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span> <span class="o">==</span> <span class="n">fs_2d</span>
        <span class="n">z_stretch_func</span> <span class="o">=</span> <span class="n">z_stretch_fact</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z_stretch_func</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">z_stretch_fact</span><span class="p">)</span>

    <span class="c1"># number of nodes in vertical direction</span>
    <span class="n">n_vert_nodes</span> <span class="o">=</span> <span class="n">fs_3d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span> <span class="o">/</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>

    <span class="n">min_depth_arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_layers</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span><span class="o">*</span><span class="mf">1e22</span>
    <span class="k">if</span> <span class="n">min_depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">min_depth</span><span class="p">):</span>
            <span class="n">min_depth_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
    <span class="n">min_depth_op2</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">min_depth_arr</span><span class="p">),</span> <span class="n">min_depth_arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;min_depth&#39;</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        void my_kernel(double *new_coords, double *old_coords, double *bath2d, double *z_stretch, int *idx, double *min_depth) {</span>
<span class="s2">            for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                double s_fact = z_stretch[d];</span>
<span class="s2">                for ( int e = 0; e &lt; </span><span class="si">%(v_nodes)d</span><span class="s2">; e++ ) {</span>
<span class="s2">                    new_coords[3*(idx[d]+e) + 0] = old_coords[3*(idx[d]+e) + 0];</span>
<span class="s2">                    new_coords[3*(idx[d]+e) + 1] = old_coords[3*(idx[d]+e) + 1];</span>
<span class="s2">                    double sigma = 1.0 - old_coords[3*(idx[d]+e) + 2]; // top 0, bot 1</span>
<span class="s2">                    double new_z = -bath2d[d] * pow(sigma, s_fact) ;</span>
<span class="s2">                    int layer = fmin(fmax(round(sigma*(</span><span class="si">%(n_layers)d</span><span class="s2"> + 1) - 1.0), 0.0), </span><span class="si">%(n_layers)d</span><span class="s2">);</span>
<span class="s2">                    double max_z = -min_depth[layer];</span>
<span class="s2">                    new_z = fmax(new_z, max_z);</span>
<span class="s2">                    new_coords[3*(idx[d]+e) + 2] = new_z;</span>
<span class="s2">                }</span>
<span class="s2">            }</span>
<span class="s2">        }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">(),</span>
                <span class="s1">&#39;v_nodes&#39;</span><span class="p">:</span> <span class="n">n_vert_nodes</span><span class="p">,</span>
                <span class="s1">&#39;n_layers&#39;</span><span class="p">:</span> <span class="n">n_layers</span><span class="p">},</span>
        <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

    <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                 <span class="n">new_coordinates</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">coordinates</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">z_stretch_func</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                 <span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                 <span class="n">min_depth_op2</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                 <span class="n">iteration_region</span><span class="o">=</span><span class="n">op2</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span>

    <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">new_coordinates</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mesh</span></div>



<div class="viewcode-block" id="comp_volume_2d">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_volume_2d">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.comp_volume_2d&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">comp_volume_2d</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">bath</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes volume of the 2D domain as an integral of the elevation field&quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">((</span><span class="n">eta</span><span class="o">+</span><span class="n">bath</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>



<div class="viewcode-block" id="comp_volume_3d">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_volume_3d">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.comp_volume_3d&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">comp_volume_3d</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes volume of the 3D domain as an integral&quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">val</span></div>



<div class="viewcode-block" id="comp_tracer_mass_2d">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_tracer_mass_2d">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.comp_tracer_mass_2d&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">comp_tracer_mass_2d</span><span class="p">(</span><span class="n">scalar_func</span><span class="p">,</span> <span class="n">total_depth</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes total tracer mass in the 2D domain</span>
<span class="sd">    :arg scalar_func: depth-averaged scalar :class:`Function` to integrate</span>
<span class="sd">    :arg total_depth: scalar UFL expression (e.g. from get_total_depth())</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">scalar_func</span><span class="o">*</span><span class="n">total_depth</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>



<div class="viewcode-block" id="comp_tracer_mass_3d">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.comp_tracer_mass_3d">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.comp_tracer_mass_3d&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">comp_tracer_mass_3d</span><span class="p">(</span><span class="n">scalar_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes total tracer mass in the 3D domain</span>

<span class="sd">    :arg scalar_func: scalar :class:`Function` to integrate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">scalar_func</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>



<div class="viewcode-block" id="get_zcoord_from_mesh">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.get_zcoord_from_mesh">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_zcoord_from_mesh&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_zcoord_from_mesh</span><span class="p">(</span><span class="n">zcoord</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates z coordinates from the 3D mesh</span>

<span class="sd">    :arg zcoord: scalar :class:`Function` where coordinates will be stored</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO coordinates should probably be interpolated instead</span>
    <span class="k">if</span> <span class="n">solver_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
    <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">tri</span><span class="o">*</span><span class="n">test</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">test</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">l</span><span class="p">,</span> <span class="n">zcoord</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zcoord</span></div>



<div class="viewcode-block" id="compute_baroclinic_head">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_baroclinic_head">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.compute_baroclinic_head&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_baroclinic_head</span><span class="p">(</span><span class="n">solver</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the baroclinic head :math:`r` from the density field</span>

<span class="sd">    .. math::</span>
<span class="sd">        r = \frac{1}{\rho_0} \int_{z}^\eta  \rho&#39; d\zeta.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;density_solve&#39;</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">density_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;rho_integral&#39;</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">rho_integrator</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">baroc_head_3d</span> <span class="o">*=</span> <span class="o">-</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0_inv&#39;</span><span class="p">]</span>
    <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;int_pg_solve&#39;</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">int_pg_calculator</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>



<div class="viewcode-block" id="extend_function_to_3d">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.extend_function_to_3d">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.extend_function_to_3d&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">extend_function_to_3d</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">mesh_extruded</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a 3D view of a 2D :class:`Function` on the extruded domain.</span>

<span class="sd">    The 3D function resides in V x R function space, where V is the function</span>
<span class="sd">    space of the source function. The 3D function shares the data of the 2D</span>
<span class="sd">    function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">fs</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">geometric_dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Function must be in 2D space&#39;</span>
    <span class="n">ufl_elem</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span>
    <span class="n">family</span> <span class="o">=</span> <span class="n">ufl_elem</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
    <span class="n">degree</span> <span class="o">=</span> <span class="n">ufl_elem</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ufl_elem</span><span class="p">,</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">VectorElement</span><span class="p">):</span>
        <span class="c1"># vector function space</span>
        <span class="n">fs_extended</span> <span class="o">=</span> <span class="n">get_functionspace</span><span class="p">(</span><span class="n">mesh_extruded</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fs_extended</span> <span class="o">=</span> <span class="n">get_functionspace</span><span class="p">(</span><span class="n">mesh_extruded</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">func_extended</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_extended</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
    <span class="n">func_extended</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func_extended</span></div>



<div class="viewcode-block" id="ExtrudedFunction">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.ExtrudedFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExtrudedFunction</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A 2D :class:`Function` that provides a 3D view on the extruded domain.</span>

<span class="sd">    The 3D function can be accessed as `ExtrudedFunction.view_3d`.</span>
<span class="sd">    The 3D function resides in V x R function space, where V is the function</span>
<span class="sd">    space of the source function. The 3D function shares the data of the 2D</span>
<span class="sd">    function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">mesh_3d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a 2D :class:`Function` with a 3D view on extruded mesh.</span>

<span class="sd">        :arg mesh_3d: Extruded 3D mesh where the function will be extended to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create the 2d function</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mesh_3d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">view_3d</span> <span class="o">=</span> <span class="n">extend_function_to_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_3d</span><span class="p">)</span></div>



<div class="viewcode-block" id="SubdomainProjector">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.SubdomainProjector">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SubdomainProjector</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Projector that projects the restriction of an expression to the specified subdomain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v_out</span><span class="p">,</span> <span class="n">subdomain_id</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constant_jacobian</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Function</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only project UFL expression or Functions not &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_out</span> <span class="o">=</span> <span class="n">v_out</span>

        <span class="n">V</span> <span class="o">=</span> <span class="n">v_out</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">subdomain_id</span><span class="p">)</span>

        <span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">v_out</span><span class="p">,</span>
                                           <span class="n">constant_jacobian</span><span class="o">=</span><span class="n">constant_jacobian</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">solver_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">,</span> <span class="s2">&quot;cg&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span>
                                              <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="SubdomainProjector.project">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.SubdomainProjector.project">[docs]</a>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.SubdomainProjector.project&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the projection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="compute_elem_height">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_elem_height">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.compute_elem_height&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_elem_height</span><span class="p">(</span><span class="n">zcoord</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the element height on an extruded mesh.</span>

<span class="sd">    :arg zcoord: field that contains the z coordinates of the mesh</span>
<span class="sd">    :type zcoord: :class:`Function`</span>
<span class="sd">    :arg output: field where element height is stored</span>
<span class="sd">    :type output: :class:`Function`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fs_in</span> <span class="o">=</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">fs_out</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

    <span class="n">iterate</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">ALL</span>

    <span class="c1"># NOTE height maybe &lt;0 if mesh was extruded like that</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        void my_kernel(double *func, double *zcoord) {</span>
<span class="s2">            for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">/2; d++ ) {</span>
<span class="s2">                for ( int c = 0; c &lt; </span><span class="si">%(func_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                    double dz = fabs(zcoord[</span><span class="si">%(func_dim)d</span><span class="s2">*(2*d+1) + c] - zcoord[</span><span class="si">%(func_dim)d</span><span class="s2">*2*d + c]);</span>
<span class="s2">                    func[</span><span class="si">%(output_dim)d</span><span class="s2">*2*d + c] = dz;</span>
<span class="s2">                    func[</span><span class="si">%(output_dim)d</span><span class="s2">*(2*d+1) + c] = dz;</span>
<span class="s2">                }</span>
<span class="s2">            }</span>
<span class="s2">        }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span><span class="o">.</span><span class="n">arity</span><span class="p">,</span>
                <span class="s1">&#39;func_dim&#39;</span><span class="p">:</span> <span class="n">zcoord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">block_size</span><span class="p">,</span>
                <span class="s1">&#39;output_dim&#39;</span><span class="p">:</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">block_size</span><span class="p">},</span>
        <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>
    <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span>
        <span class="n">kernel</span><span class="p">,</span> <span class="n">fs_out</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
        <span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">fs_out</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
        <span class="n">zcoord</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">fs_in</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
        <span class="n">iteration_region</span><span class="o">=</span><span class="n">iterate</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="get_horizontal_elem_size_2d">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.get_horizontal_elem_size_2d">[docs]</a>
<span class="nd">@no_annotations</span>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_horizontal_elem_size_2d&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_horizontal_elem_size_2d</span><span class="p">(</span><span class="n">sol2d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes horizontal element size from the 2D mesh</span>

<span class="sd">    :arg sol2d: 2D :class:`Function` where result is stored</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p1_2d</span> <span class="o">=</span> <span class="n">sol2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">p1_2d</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">p1_2d</span><span class="p">)</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">p1_2d</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">tri</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">CellVolume</span><span class="p">(</span><span class="n">mesh</span><span class="p">)))</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ksponly&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;cg&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;bjacobi&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sub_pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ilu&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">l</span><span class="p">,</span> <span class="n">sol2d</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_facet_areas">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.get_facet_areas">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_facet_areas&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_facet_areas</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute area of each facet of `mesh`. The facet areas are stored as a HDiv trace field.</span>

<span class="sd">    NOTES:</span>
<span class="sd">      * In the 2D case, this gives edge lengths.</span>
<span class="sd">      * The plus sign is arbitrary and could equally well be chosen as minus.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">HDivTrace</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;HDiv Trace&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">HDivTrace</span><span class="p">),</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">HDivTrace</span><span class="p">)</span>
    <span class="n">facet_areas</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">HDivTrace</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Facet areas&quot;</span><span class="p">)</span>
    <span class="n">mass_term</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">dS</span> <span class="o">+</span> <span class="n">v</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">ds</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">FacetArea</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">*</span><span class="n">dS</span> <span class="o">+</span> <span class="n">v</span><span class="o">*</span><span class="n">FacetArea</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ksponly&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;jacobi&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">mass_term</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">facet_areas</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">facet_areas</span></div>



<div class="viewcode-block" id="get_minimum_angles_2d">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.get_minimum_angles_2d">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_minimum_angles_2d&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_minimum_angles_2d</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the minimum angle in each element of a triangular mesh, `mesh2d`, using the</span>
<span class="sd">    cosine rule. The minimum angles are outputted as a P0 field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">topological_dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">()</span> <span class="o">==</span> <span class="n">ufl</span><span class="o">.</span><span class="n">triangle</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Minimum angle only currently implemented for triangles.&quot;</span><span class="p">)</span>
    <span class="n">edge_lengths</span> <span class="o">=</span> <span class="n">get_facet_areas</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">)</span>
    <span class="n">min_angles</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">edge_cell_node_map</span> <span class="o">=</span> <span class="n">edge_lengths</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span>
    <span class="n">min_angle_cell_node_map</span> <span class="o">=</span> <span class="n">min_angles</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span>

    <span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        void minimum_angle_kernel(double *edges, double *angle) {</span>
<span class="s2">            for (int i=0; i&lt;</span><span class="si">%(nodes)d</span><span class="s2">; i++) {</span>
<span class="s2">                  double min_edge = edges[0];</span>
<span class="s2">                  int min_index = 0;</span>

<span class="s2">                  for (int j=1; j&lt;3; j++){</span>
<span class="s2">                    if (edges[j] &lt; min_edge) {</span>
<span class="s2">                      min_edge = edges[j];</span>
<span class="s2">                      min_index = j;</span>
<span class="s2">                    }</span>
<span class="s2">                  }</span>

<span class="s2">                  double numerator = 0.0;</span>
<span class="s2">                  double denominator = 2.0;</span>

<span class="s2">                  for (int j=0; j&lt;3; j++){</span>
<span class="s2">                    if (j == min_index) {</span>
<span class="s2">                      numerator -= edges[j]*edges[j];</span>
<span class="s2">                    } else {</span>
<span class="s2">                      numerator += edges[j]*edges[j];</span>
<span class="s2">                      denominator *= edges[j];</span>
<span class="s2">                    }</span>
<span class="s2">                  }</span>
<span class="s2">                  angle[0] = acos(numerator/denominator);</span>
<span class="s2">            }</span>
<span class="s2">        }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="n">edge_cell_node_map</span><span class="o">.</span><span class="n">arity</span><span class="p">},</span> <span class="s2">&quot;minimum_angle_kernel&quot;</span><span class="p">)</span>
    <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                 <span class="n">edge_lengths</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">edge_cell_node_map</span><span class="p">),</span>
                 <span class="n">min_angles</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">RW</span><span class="p">,</span> <span class="n">min_angle_cell_node_map</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">min_angles</span></div>



<div class="viewcode-block" id="get_cell_widths_2d">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.get_cell_widths_2d">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.get_cell_widths_2d&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_cell_widths_2d</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute widths of mesh elements in each coordinate direction as the maximum distance</span>
<span class="sd">    between components of vertex coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">topological_dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">()</span> <span class="o">==</span> <span class="n">ufl</span><span class="o">.</span><span class="n">triangle</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cell widths only currently implemented for triangles.&quot;</span><span class="p">)</span>
    <span class="n">cell_widths</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
    <span class="n">coords_cell_node_map</span> <span class="o">=</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span>
    <span class="n">widths_cell_node_map</span> <span class="o">=</span> <span class="n">cell_widths</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        void cell_width_kernel(double *coords, double *widths) {</span>
<span class="s2">            for (int i=0; i&lt;</span><span class="si">%(nodes)d</span><span class="s2">; i++) {</span>
<span class="s2">                  widths[0] = fmax(widths[0], fabs(coords[2*i] - coords[(2*i+2)</span><span class="si">%%</span><span class="s2">6]));</span>
<span class="s2">                  widths[1] = fmax(widths[1], fabs(coords[2*i+1] - coords[(2*i+3)</span><span class="si">%%</span><span class="s2">6]));</span>
<span class="s2">            }</span>
<span class="s2">        }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="n">coords_cell_node_map</span><span class="o">.</span><span class="n">arity</span><span class="p">},</span> <span class="s2">&quot;cell_width_kernel&quot;</span><span class="p">)</span>
    <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">mesh2d</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                 <span class="n">mesh2d</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="n">coords_cell_node_map</span><span class="p">),</span>
                 <span class="n">cell_widths</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">MAX</span><span class="p">,</span> <span class="n">widths_cell_node_map</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cell_widths</span></div>



<div class="viewcode-block" id="anisotropic_cell_size">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.anisotropic_cell_size">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.anisotropic_cell_size&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">anisotropic_cell_size</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Measure of cell size for anisotropic meshes, as described in</span>
<span class="sd">    Micheletti et al. (2003).</span>

<span class="sd">    This is used in the SUPG formulation for the 2D tracer model.</span>

<span class="sd">    Micheletti, Perotto and Picasso (2003). Stabilized finite</span>
<span class="sd">    elements on anisotropic meshes: a priori error estimates for</span>
<span class="sd">    the advection-diffusion and the Stokes problems. SIAM Journal</span>
<span class="sd">    on Numerical Analysis 41.3: 1131-1162.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">JTJ</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">Jacobian</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Jacobian</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>

    <span class="c1"># based on https://github.com/michalhabera/dolfiny/blob/master/dolfiny/invariants.py</span>
    <span class="n">I1</span> <span class="o">=</span> <span class="n">JTJ</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">JTJ</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">JTJ</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">JTJ</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">JTJ</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">JTJ</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

    <span class="c1"># Compute smallest singular value of J</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">cell_size</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Smallest singular value&quot;</span><span class="p">)</span>
    <span class="n">cell_size</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sqrt</span><span class="p">((</span><span class="n">I1</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cell_size</span></div>



<div class="viewcode-block" id="beta_plane_coriolis_params">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.beta_plane_coriolis_params">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">beta_plane_coriolis_params</span><span class="p">(</span><span class="n">latitude</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes beta plane parameters :math:`f_0,\beta` based on latitude</span>

<span class="sd">    :arg float latitude: latitude in degrees</span>
<span class="sd">    :return: f_0, beta</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mf">7.2921150e-5</span>  <span class="c1"># rad/s Earth rotation rate</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mf">6371.e3</span>  <span class="c1"># Earth radius</span>
    <span class="c1"># Coriolis parameter f = 2 Omega sin(alpha)</span>
    <span class="c1"># Beta plane approximation f_beta = f_0 + Beta y</span>
    <span class="c1"># f_0 = 2 Omega sin(alpha_0)</span>
    <span class="c1"># Beta = df/dy|_{alpha=alpha_0}</span>
    <span class="c1">#      = (df/dalpha*dalpha/dy)_{alpha=alpha_0}</span>
    <span class="c1">#      = 2 Omega cos(alpha_0) /R</span>
    <span class="n">alpha_0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">latitude</span><span class="o">/</span><span class="mf">360.0</span>
    <span class="n">f_0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha_0</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_0</span><span class="p">)</span><span class="o">/</span><span class="n">r</span>
    <span class="k">return</span> <span class="n">f_0</span><span class="p">,</span> <span class="n">beta</span></div>



<div class="viewcode-block" id="beta_plane_coriolis_function">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.beta_plane_coriolis_function">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">beta_plane_coriolis_function</span><span class="p">(</span><span class="n">latitude</span><span class="p">,</span> <span class="n">out_function</span><span class="p">,</span> <span class="n">y_offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolates beta plane Coriolis function to a field</span>

<span class="sd">    :arg float latitude: latitude in degrees</span>
<span class="sd">    :arg out_function: :class:`Function` where to interpolate</span>
<span class="sd">    :kwarg float y_offset: offset (y - y_0) used in Beta-plane approximation.</span>
<span class="sd">        A constant in mesh coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE assumes that mesh y coordinate spans [-L_y, L_y]</span>
    <span class="n">f0</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">beta_plane_coriolis_params</span><span class="p">(</span><span class="n">latitude</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">out_function</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">())</span>
    <span class="n">out_function</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">f0</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_offset</span><span class="p">))</span></div>



<div class="viewcode-block" id="tensor_jump">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.tensor_jump">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tensor_jump</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jump term for vector functions based on the tensor product</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{jump}(\mathbf{u}, \mathbf{n}) = (\mathbf{u}^+ \mathbf{n}^+) +</span>
<span class="sd">        (\mathbf{u}^- \mathbf{n}^-)</span>

<span class="sd">    This is the discrete equivalent of grad(u) as opposed to the</span>
<span class="sd">    vectorial UFL jump operator :math:`ufl.jump` which represents div(u).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">outer</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">),</span> <span class="n">n</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="n">outer</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">),</span> <span class="n">n</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span></div>



<div class="viewcode-block" id="compute_boundary_length">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.compute_boundary_length">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_boundary_length</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the length of the boundary segments in given 2d mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">get_functionspace</span><span class="p">(</span><span class="n">mesh2d</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">boundary_markers</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mesh2d</span><span class="o">.</span><span class="n">exterior_facets</span><span class="o">.</span><span class="n">unique_markers</span><span class="p">)</span>
    <span class="n">boundary_len</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundary_markers</span><span class="p">:</span>
        <span class="n">ds_restricted</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">one_func</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">boundary_len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">one_func</span> <span class="o">*</span> <span class="n">ds_restricted</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">boundary_len</span></div>



<div class="viewcode-block" id="print_function_value_range">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.print_function_value_range">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">print_function_value_range</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;2.3g&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prints the min/max DOF values of a function.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        print_function_value_range(f, name=&#39;myfunc&#39;, prefix=&#39;Initial&#39;)</span>

<span class="sd">    Prints `Initial myfunc 0.00 .. 0.00`.</span>

<span class="sd">    :kwarg comm: MPI communicator to use for the reduction</span>
<span class="sd">    :kwarg name: Optional function name. By default uses `f.name()`</span>
<span class="sd">    :kwarg prefix: Optional prefix for the output string</span>
<span class="sd">    :kwarg format: Value formatting string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
    <span class="n">f_min</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">MPI</span><span class="o">.</span><span class="n">MIN</span><span class="p">)</span>
    <span class="n">f_max</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">MPI</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
    <span class="n">bound_str_list</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">{{</span><span class="s1">:</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="se">}}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f_min</span><span class="p">,</span> <span class="n">f_max</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">f_min</span><span class="p">,</span> <span class="n">f_max</span><span class="p">):</span>
        <span class="n">print_output</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pre</span><span class="si">}{</span><span class="n">name</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">bound_str_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">print_output</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pre</span><span class="si">}{</span><span class="n">name</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">bound_str_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> .. </span><span class="si">{</span><span class="n">bound_str_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="select_and_move_detectors">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.select_and_move_detectors">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.select_and_move_detectors&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">select_and_move_detectors</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">detector_locations</span><span class="p">,</span> <span class="n">detector_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">maximum_distance</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select those detectors that are within the domain and/or move them to</span>
<span class="sd">    the nearest cell centre within the domain</span>

<span class="sd">    :arg mesh: Defines the domain in which detectors are to be located</span>
<span class="sd">    :arg detector_locations: List of x, y locations</span>
<span class="sd">    :arg detector_names: List of detector names (optional). If provided, a list</span>
<span class="sd">       of selected locations and a list of selected detector names are returned,</span>
<span class="sd">       otherwise only a list of selected locations is returned</span>
<span class="sd">    :arg maximum_distance: Detectors whose initial locations is outside the domain,</span>
<span class="sd">      but for which the nearest cell centre is within the specified distance, are</span>
<span class="sd">      moved to this location. By default a maximum distance of 0.0 is used, i.e</span>
<span class="sd">      no detectors are moved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># auxilary function to test whether we can interpolate it in the given locations</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">P0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">VP0</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span>
    <span class="n">loc_const</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">p0xy</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">VP0</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>

    <span class="c1"># comparison operator that sorts on first entry first, etc.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">min_lexsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">datatype</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">yi</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="n">yi</span> <span class="o">&lt;</span> <span class="n">xi</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y</span>
        <span class="c1"># all entries the same:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">min_lexsort_op</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">Op</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">min_lexsort</span><span class="p">,</span> <span class="n">commute</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">move_to_nearest_cell_center</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
        <span class="n">loc_const</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="n">dist</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">xy</span><span class="o">-</span><span class="n">loc_const</span><span class="p">,</span> <span class="n">xy</span><span class="o">-</span><span class="n">loc_const</span><span class="p">))</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="c1"># smallest distance to a cell centre location on this process:</span>
        <span class="n">local_loc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p0xy</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="n">local_dist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="c1"># select the smallest distance on all processes. If some distances are equal, pick a unique loc. based on lexsort</span>
        <span class="n">global_dist_loc</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">([</span><span class="n">local_dist</span><span class="p">]</span><span class="o">+</span><span class="n">local_loc</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">min_lexsort_op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">global_dist_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">global_dist_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">accepted_locations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">accepted_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">detector_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">detector_names</span>
    <span class="k">for</span> <span class="n">location</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">PointNotInDomainError</span><span class="p">:</span>
            <span class="n">moved_dist</span><span class="p">,</span> <span class="n">location</span> <span class="o">=</span> <span class="n">move_to_nearest_cell_center</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">moved_dist</span> <span class="o">&gt;</span> <span class="n">maximum_distance</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="n">accepted_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="n">accepted_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">min_lexsort_op</span><span class="o">.</span><span class="n">Free</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">detector_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">accepted_locations</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">accepted_locations</span><span class="p">,</span> <span class="n">accepted_names</span></div>



<div class="viewcode-block" id="DepthExpression">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthExpression">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DepthExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct expression for depth depending on options</span>

<span class="sd">    If `not use_nonlinear_equations`, then the depth is simply the bathymetry:</span>

<span class="sd">  ..math::</span>
<span class="sd">        H = h</span>

<span class="sd">    Otherwise we include the free surface elevation:</span>

<span class="sd">  ..math::</span>
<span class="sd">        H = h + \eta</span>

<span class="sd">    and if `use_wetting_and_drying`, includes a bathymetry displacement term</span>
<span class="sd">    to ensure a positive depth (see Karna et al. 2011):</span>

<span class="sd">  ..math::</span>
<span class="sd">        H = h + f(h+\eta) + \eta</span>

<span class="sd">    where</span>

<span class="sd">  ..math::</span>
<span class="sd">        f(h+\eta) = (\sqrt{(h+\eta)^2 +\alpha^2} - (h+\eta))/2</span>

<span class="sd">    This introduces a wetting-drying parameter :math:`\alpha`, with dimensions</span>
<span class="sd">    of length. The value for :math:`\alpha` is specified by</span>
<span class="sd">    :attr:`.ModelOptions.wetting_and_drying_alpha`, in units of meters. The</span>
<span class="sd">    default value is 0.5, but the appropriate value is problem specific and</span>
<span class="sd">    should be set by the user.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bathymetry_2d</span><span class="p">,</span> <span class="n">use_nonlinear_equations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">use_wetting_and_drying</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wetting_and_drying_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_2d</span> <span class="o">=</span> <span class="n">bathymetry_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_nonlinear_equations</span> <span class="o">=</span> <span class="n">use_nonlinear_equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_wetting_and_drying</span> <span class="o">=</span> <span class="n">use_wetting_and_drying</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wetting_and_drying_alpha</span> <span class="o">=</span> <span class="n">wetting_and_drying_alpha</span>

<div class="viewcode-block" id="DepthExpression.wd_bathymetry_displacement">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthExpression.wd_bathymetry_displacement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wd_bathymetry_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns wetting and drying bathymetry displacement as described in:</span>
<span class="sd">        Karna et al.,  2011.</span>
<span class="sd">        :arg eta: current elevation as UFL expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_wetting_and_drying</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_2d</span> <span class="o">+</span> <span class="n">eta</span>
            <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">H</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">wetting_and_drying_alpha</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">H</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="DepthExpression.get_total_depth">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthExpression.get_total_depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_total_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns total water column depth based on options</span>
<span class="sd">        :arg eta: current elevation as UFL expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_nonlinear_equations</span><span class="p">:</span>
            <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_2d</span> <span class="o">+</span> <span class="n">eta</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">wd_bathymetry_displacement</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_2d</span>
        <span class="k">return</span> <span class="n">total_h</span></div>
</div>



<div class="viewcode-block" id="DepthIntegratedPoissonSolver">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthIntegratedPoissonSolver">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DepthIntegratedPoissonSolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct solvers for Poisson equation and updating velocities</span>

<span class="sd">    Poisson equation is related to 2d NH SWE system</span>

<span class="sd">    Non-hydrostatic pressure :math:`q` is obtained from the generic form of equation</span>

<span class="sd">    .. math::</span>
<span class="sd">        \nabla \cdot \nabla q^{n+1/2} + A \cdot \nabla q^{n+1/2} + B q^{n+1/2} + C = 0</span>

<span class="sd">    The parameter terms A, B and C are defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        A = \frac{\nabla (\eta^* - d)}{H^*}</span>
<span class="sd">        B = \nabla A - \frac{4}{(H^*)^2}</span>
<span class="sd">        C = -2 \frac{\rho_0}{\Delta t} ( \nabla \cdot \bar{\textbf{u}}^* + 2 \frac{\bar{w} - w_b}{H^*} )</span>

<span class="sd">    where the :math:`H = \eta + d` denotes the water depth</span>
<span class="sd">    and the superscript star symbol represents the intermediate level of terms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.DepthIntegratedPoissonSolver.__init__&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_2d</span><span class="p">,</span> <span class="n">uv_2d</span><span class="p">,</span> <span class="n">w_2d</span><span class="p">,</span> <span class="n">elev_2d</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">bnd_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">solver_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;snes_type&#39;</span><span class="p">:</span> <span class="s1">&#39;ksponly&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;ksp_type&#39;</span><span class="p">:</span> <span class="s1">&#39;preonly&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;mat_type&#39;</span><span class="p">:</span> <span class="s1">&#39;aij&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;pc_type&#39;</span><span class="p">:</span> <span class="s1">&#39;lu&#39;</span><span class="p">}</span>
        <span class="n">rho_0</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span> <span class="o">=</span> <span class="n">q_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span> <span class="o">=</span> <span class="n">uv_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span> <span class="o">=</span> <span class="n">w_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elev_2d</span> <span class="o">=</span> <span class="n">elev_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bnd_functions</span> <span class="o">=</span> <span class="n">bnd_functions</span>

        <span class="n">fs_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">test_q</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs_q</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">fs_q</span><span class="o">.</span><span class="n">mesh</span><span class="p">())</span>
        <span class="n">boundary_markers</span> <span class="o">=</span> <span class="n">fs_q</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">exterior_facets</span><span class="o">.</span><span class="n">unique_markers</span>

        <span class="n">bath_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">bathymetry_2d</span>
        <span class="n">h_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elev_2d</span><span class="p">)</span>
        <span class="n">w_b</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">bath_2d</span><span class="p">))</span>  <span class="c1"># TODO account for bed movement</span>

        <span class="c1"># weak form of `div(grad(q^{n+1/2}))`</span>
        <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">test_q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
        <span class="c1"># weak form of `dot(grad(self.elev_2d - bath_2d)/h_star, grad(q^{n+1/2}))`</span>
        <span class="n">grad_hori</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elev_2d</span> <span class="o">-</span> <span class="n">bath_2d</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad_hori</span><span class="o">/</span><span class="n">h_star</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">))</span><span class="o">*</span><span class="n">test_q</span><span class="o">*</span><span class="n">dx</span>
        <span class="c1"># weak form of `q^{n+1/2}*div(grad(self.elev_2d - bath_2d))/h_star`</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">*</span><span class="n">test_q</span><span class="o">/</span><span class="n">h_star</span><span class="p">),</span> <span class="n">grad_hori</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="c1"># weak form of `-q^{n+1/2}*(dot(grad(self.elev_2d - bath_2d), grad(h_star)) + 4)/h_star**2`</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">grad_hori</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">h_star</span><span class="p">))</span> <span class="o">+</span> <span class="mf">4.</span><span class="p">)</span><span class="o">/</span><span class="n">h_star</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">*</span><span class="n">test_q</span><span class="o">*</span><span class="n">dx</span>
        <span class="c1"># weak form of `-2.*rho_0/self.dt*(div(self.uv_2d) + (self.w_2d - w_b)/(0.5*h_star))`</span>
        <span class="n">const</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">rho_0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="n">const</span><span class="o">*</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">test_q</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span> <span class="o">-</span> <span class="n">w_b</span><span class="p">)</span><span class="o">/</span><span class="n">h_star</span><span class="o">*</span><span class="n">test_q</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>

        <span class="c1"># boundary conditions</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="n">boundary_markers</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bnd_functions</span><span class="p">[</span><span class="s1">&#39;shallow_water&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
            <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># e.g. inlet flow, TODO be more precise</span>
                <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">fs_q</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">))</span>
                <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">*</span><span class="n">test_q</span><span class="o">/</span><span class="n">h_star</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad_hori</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">const</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">test_q</span><span class="o">*</span><span class="n">ds_bnd</span>

        <span class="n">prob_q</span> <span class="o">=</span> <span class="n">NonlinearVariationalProblem</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_q</span> <span class="o">=</span> <span class="n">NonlinearVariationalSolver</span><span class="p">(</span>
            <span class="n">prob_q</span><span class="p">,</span>
            <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">,</span>
            <span class="n">options_prefix</span><span class="o">=</span><span class="s1">&#39;poisson_solver&#39;</span>
        <span class="p">)</span>
        <span class="c1"># horizontal velocity updater</span>
        <span class="n">fs_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">tri_u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs_u</span><span class="p">)</span>
        <span class="n">test_u</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs_u</span><span class="p">)</span>
        <span class="n">a_u</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri_u</span><span class="p">,</span> <span class="n">test_u</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">l_u</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="n">rho_0</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">)</span> <span class="o">+</span> <span class="n">grad_hori</span><span class="o">/</span><span class="n">h_star</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="p">),</span> <span class="n">test_u</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">prob_u</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a_u</span><span class="p">,</span> <span class="n">l_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uv_2d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_u</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">prob_u</span><span class="p">)</span>
        <span class="c1"># vertical velocity updater</span>
        <span class="n">fs_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">tri_w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs_w</span><span class="p">)</span>
        <span class="n">test_w</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs_w</span><span class="p">)</span>
        <span class="n">a_w</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri_w</span><span class="p">,</span> <span class="n">test_w</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">l_w</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="n">rho_0</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_2d</span><span class="o">/</span><span class="n">h_star</span><span class="p">),</span> <span class="n">test_w</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">prob_w</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a_w</span><span class="p">,</span> <span class="n">l_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_2d</span><span class="p">)</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;cg&quot;</span><span class="p">,</span>
            <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;bjacobi&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sub_pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ilu&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_w</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">prob_w</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span>

<div class="viewcode-block" id="DepthIntegratedPoissonSolver.solve">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.DepthIntegratedPoissonSolver.solve">[docs]</a>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.DepthIntegratedPoissonSolver.solve&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solve_w</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># solve non-hydrostatic pressure q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_q</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="c1"># update horizontal velocity uv_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_u</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="c1"># update vertical velocity w_2d</span>
        <span class="k">if</span> <span class="n">solve_w</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_w</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="form2indicator">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.form2indicator">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.form2indicator&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">form2indicator</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deduce the cell-wise contributions to a functional.</span>

<span class="sd">    Given a 0-form, multiply the integrand of each of its integrals by a</span>
<span class="sd">    :math:`\mathbb P0` test function and reassemble to give an element-wise error</span>
<span class="sd">    indicator.</span>

<span class="sd">    Note that a 0-form does not contain any :class:`firedrake.ufl_expr.TestFunction`\s</span>
<span class="sd">    or :class:`firedrake.ufl_expr.TrialFunction`\s.</span>

<span class="sd">    :arg F: the 0-form</span>
<span class="sd">    :return: the corresponding error indicator field</span>

<span class="sd">    Modified code based on</span>
<span class="sd">    https://github.com/pyroteus/goalie/blob/main/goalie/error_estimation.py</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">arguments</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input form should be 0-form&quot;</span><span class="p">)</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ufl_domain</span><span class="p">()</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">p0test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">CellVolume</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

    <span class="n">rhs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">integral</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">integrals_by_type</span><span class="p">(</span><span class="s2">&quot;exterior_facet&quot;</span><span class="p">):</span>
        <span class="n">dsi</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="n">integral</span><span class="o">.</span><span class="n">subdomain_id</span><span class="p">())</span>
        <span class="n">rhs</span> <span class="o">+=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">p0test</span> <span class="o">*</span> <span class="n">integral</span><span class="o">.</span><span class="n">integrand</span><span class="p">()</span> <span class="o">*</span> <span class="n">dsi</span>
    <span class="k">for</span> <span class="n">integral</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">integrals_by_type</span><span class="p">(</span><span class="s2">&quot;interior_facet&quot;</span><span class="p">):</span>
        <span class="n">dSi</span> <span class="o">=</span> <span class="n">dS</span><span class="p">(</span><span class="n">integral</span><span class="o">.</span><span class="n">subdomain_id</span><span class="p">())</span>
        <span class="n">rhs</span> <span class="o">+=</span> <span class="n">h</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">p0test</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">integral</span><span class="o">.</span><span class="n">integrand</span><span class="p">()</span> <span class="o">*</span> <span class="n">dSi</span>
        <span class="n">rhs</span> <span class="o">+=</span> <span class="n">h</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">p0test</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">integral</span><span class="o">.</span><span class="n">integrand</span><span class="p">()</span> <span class="o">*</span> <span class="n">dSi</span>
    <span class="k">for</span> <span class="n">integral</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">integrals_by_type</span><span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">):</span>
        <span class="n">dxi</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">integral</span><span class="o">.</span><span class="n">subdomain_id</span><span class="p">())</span>
        <span class="n">rhs</span> <span class="o">+=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">p0test</span> <span class="o">*</span> <span class="n">integral</span><span class="o">.</span><span class="n">integrand</span><span class="p">()</span> <span class="o">*</span> <span class="n">dxi</span>

    <span class="k">assert</span> <span class="n">rhs</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">indicator</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span>
        <span class="n">TrialFunction</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span> <span class="o">*</span> <span class="n">p0test</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">,</span>
        <span class="n">indicator</span><span class="p">,</span>
        <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ksponly&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span>
            <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;jacobi&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">indicator</span></div>



<div class="viewcode-block" id="vom_interpolator_functions">
<a class="viewcode-back" href="../../thetis.html#thetis.utility.vom_interpolator_functions">[docs]</a>
<span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;thetis.vom_interpolator_functions&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">vom_interpolator_functions</span><span class="p">(</span><span class="n">solver_obj</span><span class="p">,</span> <span class="n">field_names</span><span class="p">,</span> <span class="n">locations</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates function spaces and associated Functions for interpolation</span>
<span class="sd">    on a VertexOnlyMesh (VOM) and returns them for reuse.</span>

<span class="sd">    :arg solver_obj: Thetis solver object</span>
<span class="sd">    :arg field_names: List of field names to create functions for.</span>
<span class="sd">    :arg locations: List of locations for interpolation.</span>
<span class="sd">    :return: A dictionary mapping field names to a tuple of (f_at_points, f_at_input_points)</span>
<span class="sd">             which are Functions for interpolation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vom</span> <span class="o">=</span> <span class="n">VertexOnlyMesh</span><span class="p">(</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">mesh2d</span><span class="p">,</span> <span class="n">locations</span><span class="p">,</span> <span class="n">redundant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">functions_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">:</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">(),</span> <span class="n">VectorElement</span><span class="p">):</span>
            <span class="n">P0DG</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">vom</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">P0DG_input_ordering</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">vom</span><span class="o">.</span><span class="n">input_ordering</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P0DG</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">vom</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">P0DG_input_ordering</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">vom</span><span class="o">.</span><span class="n">input_ordering</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">f_at_points</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P0DG</span><span class="p">)</span>
        <span class="n">f_at_input_points</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P0DG_input_ordering</span><span class="p">)</span>

        <span class="c1"># Store the Functions in the dictionary keyed by field name</span>
        <span class="n">functions_dict</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_at_points</span><span class="p">,</span> <span class="n">f_at_input_points</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">functions_dict</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2016-2025, Tuomas Kärnä et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>