
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>thetis.utility3d &#8212; Thetis 0+untagged.1689.ge390b9e documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/thetis.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<!-- <link rel="stylesheet" href="../../_static/featured.css"> -->


<link rel="shortcut icon" href="../../_static/icon_thetis.ico" />


  </head><body>
<div class="wrapper">
  <a href="../../index.html"><img src="../../_static/banner.jpg" height="180px" alt="Thetis Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
        <li class="page_item"><a href="../../documentation.html" title="Thetis documentation">Documentation</a></li>
        <li class="page_item"><a href="../../download.html" title="Install Thetis">Download</a></li>
        <li class="page_item"><a href="../../team.html" title="Development team">Team</a></li>
        <li class="page_item"><a href="../../publications.html" title="Publications">Publications</a></li>
        <li class="page_item"><a href="../../funding.html" title="Our financial supporters">Funding</a></li>
        <li class="page_item"><a href="../../contact.html" title="Getting in touch">Contact</a></li>
        <li class="page_item"><a href="https://github.com/thetisproject/thetis" title="Thetis source on GitHub">GitHub</a></li>
        <li class="page_item"><a href="https://jenkins.ese.ic.ac.uk:1080/blue/organizations/jenkins/thetis/branches" title="Thetis build status">Jenkins</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="_modules/thetis/utility3d">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for thetis.utility3d</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utility solvers and calculators for 3D hydrostatic ocean model</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">.utility</span> <span class="kn">import</span> <span class="o">*</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;VerticalVelocitySolver&quot;</span><span class="p">,</span>
    <span class="s2">&quot;VerticalIntegrator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DensitySolver&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DensitySolverWeak&quot;</span><span class="p">,</span>
    <span class="s2">&quot;VelocityMagnitudeSolver&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Mesh3DConsistencyCalculator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ExpandFunctionTo3d&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SubFunctionExtractor&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ALEMeshUpdater&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SmagorinskyViscosity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;EquationOfState&quot;</span><span class="p">,</span>
    <span class="s2">&quot;JackettEquationOfState&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LinearEquationOfState&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_horizontal_elem_size_3d&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="VerticalVelocitySolver"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.VerticalVelocitySolver">[docs]</a><span class="k">class</span> <span class="nc">VerticalVelocitySolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes vertical velocity diagnostically from the continuity equation</span>

<span class="sd">    Vertical velocity is obtained from the continuity equation</span>

<span class="sd">    .. math::</span>
<span class="sd">        \frac{\partial w}{\partial z} = -\nabla_h \cdot \textbf{u}</span>
<span class="sd">        :label: continuity_eq_3d</span>

<span class="sd">    and the bottom impermeability condition (:math:`h` denotes the bathymetry)</span>

<span class="sd">    .. math::</span>
<span class="sd">        \textbf{n}_h \cdot \textbf{u} + w n_z &amp;= 0 \quad \forall \mathbf{x} \in \Gamma_{b} \\</span>
<span class="sd">        \Leftrightarrow w &amp;= -\nabla_h h \cdot \mathbf{u} \quad \forall \mathbf{x} \in \Gamma_{b}</span>

<span class="sd">    :math:`w` can be solved with the weak form</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_{\Gamma_s} w n_z \varphi dS</span>
<span class="sd">        + \int_{\mathcal{I}_h} \text{avg}(w) \text{jump}(\varphi n_z) dS</span>
<span class="sd">        - \int_{\Omega} w \frac{\partial \varphi}{\partial z} dx</span>
<span class="sd">        = \\</span>
<span class="sd">        \int_{\Omega} \mathbf{u} \cdot \nabla_h \varphi dx</span>
<span class="sd">        - \int_{\mathcal{I}_h \cup \mathcal{I}_v} \text{avg}(\mathbf{u}) \cdot \text{jump}(\varphi \mathbf{n}_h) dS</span>
<span class="sd">        - \int_{\Gamma_s} \mathbf{u} \cdot \varphi \mathbf{n}_h dS</span>

<span class="sd">    where the :math:`\Gamma_b` terms vanish due to the bottom impermeability</span>
<span class="sd">    condition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span> <span class="n">boundary_funcs</span><span class="o">=</span><span class="p">{},</span>
                 <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solution: w :class:`Function`</span>
<span class="sd">        :arg uv: horizontal velocity :class:`Function`</span>
<span class="sd">        :arg bathymetry: bathymetry :class:`Function`</span>
<span class="sd">        :kwarg dict boundary_funcs: boundary conditions used in the 3D momentum</span>
<span class="sd">            equation. Provides external values of uv (if any).</span>
<span class="sd">        :kwarg dict solver_parameters: PETSc solver options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">solver_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;snes_type&#39;</span><span class="p">,</span> <span class="s1">&#39;ksponly&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_type&#39;</span><span class="p">,</span> <span class="s1">&#39;preonly&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;pc_type&#39;</span><span class="p">,</span> <span class="s1">&#39;bjacobi&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sub_ksp_type&#39;</span><span class="p">,</span> <span class="s1">&#39;preonly&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sub_pc_type&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sub_pc_factor_shift_type&#39;</span><span class="p">,</span> <span class="s1">&#39;inblocks&#39;</span><span class="p">)</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># define measures with a reasonable quadrature degree</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span> <span class="o">=</span> <span class="n">dS_h</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dS_v</span> <span class="o">=</span> <span class="n">dS_v</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span> <span class="o">=</span> <span class="n">ds_surf</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>

        <span class="c1"># NOTE weak dw/dz</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">ds_surf</span> <span class="o">+</span> \
            <span class="n">avg</span><span class="p">(</span><span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">dS_h</span> <span class="o">-</span> <span class="n">Dx</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

        <span class="c1"># NOTE weak div(uv)</span>
        <span class="n">uv_star</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
        <span class="c1"># NOTE in the case of mimetic uv the div must be taken over all components</span>
        <span class="n">l_v_facet</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_star</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                     <span class="o">+</span> <span class="n">uv_star</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                     <span class="o">+</span> <span class="n">uv_star</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS_v</span>
        <span class="n">l_h_facet</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_star</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                     <span class="o">+</span> <span class="n">uv_star</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                     <span class="o">+</span> <span class="n">uv_star</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span>
        <span class="n">l_surf</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                  <span class="o">+</span> <span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">uv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span>
        <span class="n">l_vol</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">l_vol</span> <span class="o">-</span> <span class="n">l_v_facet</span> <span class="o">-</span> <span class="n">l_h_facet</span> <span class="o">-</span> <span class="n">l_surf</span>
        <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">exterior_facets</span><span class="o">.</span><span class="n">unique_markers</span><span class="p">):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">boundary_funcs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
            <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds_v</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># assume land boundary</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use symmetry condition</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">test</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">ds_bnd</span>

        <span class="c1"># NOTE For ALE mesh constant_jacobian should be False</span>
        <span class="c1"># however the difference is very small as A is nearly independent of</span>
        <span class="c1"># mesh stretching: only the normals vary in time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span>
                                             <span class="n">constant_jacobian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span>
                                              <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="VerticalVelocitySolver.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.VerticalVelocitySolver.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute w&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="VerticalIntegrator"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.VerticalIntegrator">[docs]</a><span class="k">class</span> <span class="nc">VerticalIntegrator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes vertical integral (or average) of a field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">bottom_to_top</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">bnd_value</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">bathymetry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elevation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg input: 3D field to integrate</span>
<span class="sd">        :arg output: 3D field where the integral is stored</span>
<span class="sd">        :kwarg bottom_to_top: Defines the integration direction: If True integration is performed along the z axis, from bottom surface to top surface.</span>
<span class="sd">        :kwarg bnd_value: Value of the integral at the bottom (top) boundary if bottom_to_top is True (False)</span>
<span class="sd">        :kwarg average: If True computes the vertical average instead. Requires bathymetry and elevation fields</span>
<span class="sd">        :kwarg bathymetry: 3D field defining the bathymetry</span>
<span class="sd">        :kwarg elevation: 3D field defining the free surface elevation</span>
<span class="sd">        :kwarg dict solver_parameters: PETSc solver options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
        <span class="n">e_continuity</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>
        <span class="n">vertical_is_dg</span> <span class="o">=</span> <span class="n">e_continuity</span><span class="o">.</span><span class="n">vertical</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dg&#39;</span><span class="p">,</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">solver_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;snes_type&#39;</span><span class="p">,</span> <span class="s1">&#39;ksponly&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e_continuity</span><span class="o">.</span><span class="n">vertical</span> <span class="o">!=</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">:</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_type&#39;</span><span class="p">,</span> <span class="s1">&#39;preonly&#39;</span><span class="p">)</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;pc_type&#39;</span><span class="p">,</span> <span class="s1">&#39;bjacobi&#39;</span><span class="p">)</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sub_ksp_type&#39;</span><span class="p">,</span> <span class="s1">&#39;preonly&#39;</span><span class="p">)</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sub_pc_type&#39;</span><span class="p">,</span> <span class="s1">&#39;ilu&#39;</span><span class="p">)</span>

        <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># define measures with a reasonable quadrature degree</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">p_in</span><span class="p">,</span> <span class="n">q_in</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">p_in</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="o">+</span><span class="n">q_in</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span> <span class="o">=</span> <span class="n">dS_h</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span> <span class="o">=</span> <span class="n">ds_surf</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds_bottom</span> <span class="o">=</span> <span class="n">ds_bottom</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bottom_to_top</span><span class="p">:</span>
            <span class="n">bnd_term</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">bnd_value</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_bottom</span>
            <span class="n">mass_bnd_term</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bnd_term</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">bnd_value</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_surf</span>
            <span class="n">mass_bnd_term</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ds_bottom</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">Dx</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">tri</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="n">mass_bnd_term</span>
        <span class="k">if</span> <span class="n">bottom_to_top</span><span class="p">:</span>
            <span class="n">up_value</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">up_value</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vertical_is_dg</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+=</span> <span class="n">up_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+=</span> <span class="n">up_value</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS_h</span>
        <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">input</span><span class="o">/</span><span class="p">(</span><span class="n">elevation</span> <span class="o">+</span> <span class="n">bathymetry</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="n">bnd_term</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">constant_jacobian</span><span class="o">=</span><span class="n">average</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="VerticalIntegrator.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.VerticalIntegrator.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the integral and stores it in the output field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="DensitySolver"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.DensitySolver">[docs]</a><span class="k">class</span> <span class="nc">DensitySolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes density from salinity and temperature using the equation of state.</span>

<span class="sd">    Water density is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \rho = \rho&#39;(T, S, p) + \rho_0</span>

<span class="sd">    This method computes the density anomaly :math:`\rho&#39;`.</span>

<span class="sd">    Density is computed point-wise assuming that temperature, salinity and</span>
<span class="sd">    density are in the same function space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">salinity</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">eos_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg salinity: water salinity field</span>
<span class="sd">        :type salinity: :class:`Function`</span>
<span class="sd">        :arg temperature: water temperature field</span>
<span class="sd">        :type temperature: :class:`Function`</span>
<span class="sd">        :arg density: water density field</span>
<span class="sd">        :type density: :class:`Function`</span>
<span class="sd">        :arg eos_class: equation of state that defines water density</span>
<span class="sd">        :type eos_class: :class:`EquationOfState`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">density</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eos</span> <span class="o">=</span> <span class="n">eos_class</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">salinity</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">==</span> <span class="n">salinity</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">==</span> <span class="n">temperature</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">salinity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">density</span>

    <span class="k">def</span> <span class="nf">_get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns numpy data array from a :class:`Function`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">==</span> <span class="n">function</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># assume that function is a float</span>
        <span class="k">return</span> <span class="n">function</span>

<div class="viewcode-block" id="DensitySolver.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.DensitySolver.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute density&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
        <span class="n">th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># NOTE ignore pressure for now</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eos</span><span class="o">.</span><span class="n">compute_rho</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DensitySolverWeak"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.DensitySolverWeak">[docs]</a><span class="k">class</span> <span class="nc">DensitySolverWeak</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes density from salinity and temperature using the equation of state.</span>

<span class="sd">    Water density is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \rho = \rho&#39;(T, S, p) + \rho_0</span>

<span class="sd">    This method computes the density anomaly :math:`\rho&#39;`.</span>

<span class="sd">    Density is computed in a weak sense by projecting the analytical expression</span>
<span class="sd">    on the density field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">salinity</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">eos_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg salinity: water salinity field</span>
<span class="sd">        :type salinity: :class:`Function`</span>
<span class="sd">        :arg temperature: water temperature field</span>
<span class="sd">        :type temperature: :class:`Function`</span>
<span class="sd">        :arg density: water density field</span>
<span class="sd">        :type density: :class:`Function`</span>
<span class="sd">        :arg eos_class: equation of state that defines water density</span>
<span class="sd">        :type eos_class: :class:`EquationOfState`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">density</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eos</span> <span class="o">=</span> <span class="n">eos_class</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">salinity</span><span class="p">,</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Constant</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Constant</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">salinity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="n">density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0&#39;</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eos</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projector</span> <span class="o">=</span> <span class="n">Projector</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">density</span><span class="p">)</span>

<div class="viewcode-block" id="DensitySolverWeak.ensure_positive_salinity"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.DensitySolverWeak.ensure_positive_salinity">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_positive_salinity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        make sure salinity is not negative</span>

<span class="sd">        some EOS depend on sqrt(salt).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME this is really hacky and modifies the state variable</span>
        <span class="c1"># NOTE if salt field is P2 checking nodal values is not enough ..</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="DensitySolverWeak.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.DensitySolverWeak.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute density&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_positive_salinity</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projector</span><span class="o">.</span><span class="n">project</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="VelocityMagnitudeSolver"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.VelocityMagnitudeSolver">[docs]</a><span class="k">class</span> <span class="nc">VelocityMagnitudeSolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes magnitude of (u[0],u[1],w) and stores it in solution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_val</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                 <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solution: scalar field for velocity magnitude scalar :class:`Function`</span>
<span class="sd">        :type solution: :class:`Function`</span>
<span class="sd">        :kwarg u: horizontal velocity</span>
<span class="sd">        :type u: :class:`Function`</span>
<span class="sd">        :kwarg w: vertical velocity</span>
<span class="sd">        :type w: :class:`Function`</span>
<span class="sd">        :kwarg float min_val: minimum value of magnitude. Minimum value of solution</span>
<span class="sd">            will be clipped to this value</span>
<span class="sd">        :kwarg dict solver_parameters: PETSc solver options</span>


<span class="sd">        If ``u`` is None computes magnitude of (0,0,w).</span>

<span class="sd">        If ``w`` is None computes magnitude of (u[0],u[1],0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span> <span class="o">=</span> <span class="n">min_val</span>
        <span class="n">function_space</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">test</span><span class="o">*</span><span class="n">tri</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">test</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="VelocityMagnitudeSolver.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.VelocityMagnitudeSolver.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the magnitude&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Mesh3DConsistencyCalculator"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.Mesh3DConsistencyCalculator">[docs]</a><span class="k">class</span> <span class="nc">Mesh3DConsistencyCalculator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a hydrostatic consistency criterion metric on the 3D mesh.</span>

<span class="sd">    Let :math:`\Delta x` and :math:`\Delta z` denote the horizontal and vertical</span>
<span class="sd">    element sizes. The hydrostatic consistency criterion (HCC) can then be</span>
<span class="sd">    expressed as</span>

<span class="sd">    .. math::</span>
<span class="sd">        R = \frac{|\nabla h| \Delta x}{\Delta z} &lt; 1</span>

<span class="sd">    where :math:`\nabla h` is the bathymetry gradient (or gradient of the</span>
<span class="sd">    internal horizontal facet).</span>

<span class="sd">    Violating the hydrostatic consistency criterion leads to internal pressure</span>
<span class="sd">    gradient errors.</span>
<span class="sd">    In practice one can violate the :math:`R &lt; 1` condition without</span>
<span class="sd">    jeopardizing numerical stability; typically :math:`R &lt; 5`.</span>
<span class="sd">    Mesh consistency can be improved by coarsening the vertical</span>
<span class="sd">    mesh, refining the horizontal mesh, or smoothing the bathymetry.</span>

<span class="sd">    For a 3D prism, let :math:`\delta z_t,\delta z_b` denote the maximal</span>
<span class="sd">    :math:`z` coordinate difference in the surface and bottom facets,</span>
<span class="sd">    respectively, and :math:`\Delta z` the height of the prism.</span>
<span class="sd">    We can then compute :math:`R` for the two facets as</span>

<span class="sd">    .. math::</span>
<span class="sd">        R_t &amp;= \frac{\delta z_t}{\Delta z} \\</span>
<span class="sd">        R_b &amp;= \frac{\delta z_b}{\Delta z}</span>

<span class="sd">    For a straight prism we have :math:`R = 0`, and :math:`R = 1` in</span>
<span class="sd">    the case where the highest bottom node is at the same level as the lowest</span>
<span class="sd">    surface node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: :class:`FlowSolver` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span> <span class="o">=</span> <span class="n">solver_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">hcc_metric_3d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_coord</span> <span class="o">=</span> <span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_3d</span>

        <span class="c1"># create par loop for computing delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">function_spaces</span><span class="o">.</span><span class="n">P1DG</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            void my_kernel(double *output, double *z_field, int *idx) {</span>
<span class="s2">                // compute max delta z on top and bottom facets</span>
<span class="s2">                double z_top_max = -1e20;</span>
<span class="s2">                double z_top_min = 1e20;</span>
<span class="s2">                double z_bot_max = -1e20;</span>
<span class="s2">                double z_bot_min = 1e20;</span>
<span class="s2">                int i_top = 1;</span>
<span class="s2">                int i_bot = 0;</span>
<span class="s2">                for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                    double z_top = z_field[idx[d] + i_top];</span>
<span class="s2">                    double z_bot = z_field[idx[d] + i_bot];</span>
<span class="s2">                    z_top_max = fmax(z_top, z_top_max);</span>
<span class="s2">                    z_top_min = fmin(z_top, z_top_min);</span>
<span class="s2">                    z_bot_max = fmax(z_bot, z_bot_max);</span>
<span class="s2">                    z_bot_min = fmin(z_bot, z_bot_min);</span>
<span class="s2">                }</span>
<span class="s2">                double delta_z_top = z_top_max - z_top_min;</span>
<span class="s2">                double delta_z_bot = z_bot_max - z_bot_min;</span>
<span class="s2">                // compute R ratio</span>
<span class="s2">                for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                    double z_top = z_field[idx[d] + i_top];</span>
<span class="s2">                    double z_bot = z_field[idx[d] + i_bot];</span>
<span class="s2">                    double h = z_top - z_bot;</span>
<span class="s2">                    output[idx[d] + i_top] = delta_z_top/h;</span>
<span class="s2">                    output[idx[d] + i_bot] = delta_z_bot/h;</span>
<span class="s2">                }</span>
<span class="s2">            }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)},</span>
            <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Mesh3DConsistencyCalculator.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.Mesh3DConsistencyCalculator.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the HCC metric&quot;&quot;&quot;</span>
        <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">z_coord</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_coord</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                     <span class="n">iterate</span><span class="o">=</span><span class="n">op2</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span>
        <span class="c1"># compute global min/max</span>
        <span class="n">r_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">r_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">r_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">r_min</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">MIN</span><span class="p">)</span>
        <span class="n">r_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">r_max</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>
        <span class="n">print_output</span><span class="p">(</span><span class="s1">&#39;HCC: </span><span class="si">{:}</span><span class="s1"> .. </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="ExpandFunctionTo3d"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.ExpandFunctionTo3d">[docs]</a><span class="k">class</span> <span class="nc">ExpandFunctionTo3d</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy a 2D field to 3D</span>

<span class="sd">    Copies a field from 2D mesh to 3D mesh, assigning the same value over the</span>
<span class="sd">    vertical dimension. Horizontal function spaces must be the same.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        U = FunctionSpace(mesh, &#39;DG&#39;, 1)</span>
<span class="sd">        U_2d = FunctionSpace(mesh2d, &#39;DG&#39;, 1)</span>
<span class="sd">        func2d = Function(U_2d)</span>
<span class="sd">        func3d = Function(U)</span>
<span class="sd">        ex = ExpandFunctionTo3d(func2d, func3d)</span>
<span class="sd">        ex.solve()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_2d</span><span class="p">,</span> <span class="n">output_3d</span><span class="p">,</span> <span class="n">elem_height</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg input_2d: 2D source field</span>
<span class="sd">        :type input_2d: :class:`Function`</span>
<span class="sd">        :arg output_3d: 3D target field</span>
<span class="sd">        :type output_3d: :class:`Function`</span>
<span class="sd">        :kwarg elem_height: scalar :class:`Function` in 3D mesh that defines</span>
<span class="sd">            the vertical element size. Needed only in the case of HDiv function</span>
<span class="sd">            spaces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_2d</span> <span class="o">=</span> <span class="n">input_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span> <span class="o">=</span> <span class="n">output_3d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

        <span class="n">family_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
        <span class="n">base_element_3d</span> <span class="o">=</span> <span class="n">get_extruded_base_element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_element_3d</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TensorProductElement</span><span class="p">)</span>
        <span class="n">family_3dh</span> <span class="o">=</span> <span class="n">base_element_3d</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">family_2d</span> <span class="o">!=</span> <span class="n">family_3dh</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;2D and 3D spaces do not match: </span><span class="si">{0:s}</span><span class="s1"> </span><span class="si">{1:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">family_2d</span><span class="p">,</span> <span class="n">family_3dh</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_hdiv_scaling</span> <span class="o">=</span> <span class="n">family_2d</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Raviart-Thomas&#39;</span><span class="p">,</span> <span class="s1">&#39;RTCF&#39;</span><span class="p">,</span> <span class="s1">&#39;Brezzi-Douglas-Marini&#39;</span><span class="p">,</span> <span class="s1">&#39;BDMCF&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_hdiv_scaling</span> <span class="ow">and</span> <span class="n">elem_height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;elem_height must be provided for HDiv spaces&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">ALL</span>

        <span class="c1"># number of nodes in vertical direction</span>
        <span class="n">n_vert_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            void my_kernel(double *func, double *func2d, int *idx) {</span>
<span class="s2">                for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                    for ( int c = 0; c &lt; </span><span class="si">%(func2d_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                        for ( int e = 0; e &lt; </span><span class="si">%(v_nodes)d</span><span class="s2">; e++ ) {</span>
<span class="s2">                            func[</span><span class="si">%(func3d_dim)d</span><span class="s2">*(idx[d]+e) + c] = func2d[</span><span class="si">%(func2d_dim)d</span><span class="s2">*d + c];</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }</span>
<span class="s2">            }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">(),</span>
                    <span class="s1">&#39;func2d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                    <span class="s1">&#39;func3d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                    <span class="s1">&#39;v_nodes&#39;</span><span class="p">:</span> <span class="n">n_vert_nodes</span><span class="p">},</span>
            <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_hdiv_scaling</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">)</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span><span class="o">*</span><span class="n">elem_height</span><span class="o">*</span><span class="n">dx</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rt_scale_solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span>
                <span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="ExpandFunctionTo3d.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.ExpandFunctionTo3d.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;copy_2d_to_3d&#39;</span><span class="p">):</span>
            <span class="c1"># execute par loop</span>
            <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_3d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                <span class="n">iterate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_hdiv_scaling</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rt_scale_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="SubFunctionExtractor"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.SubFunctionExtractor">[docs]</a><span class="k">class</span> <span class="nc">SubFunctionExtractor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a 2D sub-function from a 3D function in an extruded mesh</span>

<span class="sd">    Given 2D and 3D functions,</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        U = FunctionSpace(mesh, &#39;DG&#39;, 1)</span>
<span class="sd">        U_2d = FunctionSpace(mesh2d, &#39;DG&#39;, 1)</span>
<span class="sd">        func2d = Function(U_2d)</span>
<span class="sd">        func3d = Function(U)</span>

<span class="sd">    Get surface value:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        ex = SubFunctionExtractor(func3d, func2d,</span>
<span class="sd">            boundary=&#39;top&#39;, elem_facet=&#39;top&#39;)</span>
<span class="sd">        ex.solve()</span>

<span class="sd">    Get bottom value:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        ex = SubFunctionExtractor(func3d, func2d,</span>
<span class="sd">            boundary=&#39;bottom&#39;, elem_facet=&#39;bottom&#39;)</span>
<span class="sd">        ex.solve()</span>

<span class="sd">    Get value at the top of bottom element:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        ex = SubFunctionExtractor(func3d, func2d,</span>
<span class="sd">            boundary=&#39;bottom&#39;, elem_facet=&#39;top&#39;)</span>
<span class="sd">        ex.solve()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_3d</span><span class="p">,</span> <span class="n">output_2d</span><span class="p">,</span>
                 <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">elem_facet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">elem_height</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg input_3d: 3D source field</span>
<span class="sd">        :type input_3d: :class:`Function`</span>
<span class="sd">        :arg output_2d: 2D target field</span>
<span class="sd">        :type output_2d: :class:`Function`</span>
<span class="sd">        :kwarg str boundary: &#39;top&#39;|&#39;bottom&#39;</span>
<span class="sd">            Defines whether to extract from the surface or bottom 3D elements</span>
<span class="sd">        :kwarg str elem_facet: &#39;top&#39;|&#39;bottom&#39;|&#39;average&#39;</span>
<span class="sd">            Defines which facet of the 3D element is extracted. The &#39;average&#39;</span>
<span class="sd">            computes mean of the top and bottom facets of the 3D element.</span>
<span class="sd">        :kwarg elem_height: scalar :class:`Function` in 2D mesh that defines</span>
<span class="sd">            the vertical element size. Needed only in the case of HDiv function</span>
<span class="sd">            spaces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_3d</span> <span class="o">=</span> <span class="n">input_3d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span> <span class="o">=</span> <span class="n">output_2d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_3d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">elem_facet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># extract surface/bottom face by default</span>
            <span class="n">elem_facet</span> <span class="o">=</span> <span class="n">boundary</span>

        <span class="n">family_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
        <span class="n">base_element_3d</span> <span class="o">=</span> <span class="n">get_extruded_base_element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_element_3d</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TensorProductElement</span><span class="p">)</span>
        <span class="n">family_3dh</span> <span class="o">=</span> <span class="n">base_element_3d</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">family_2d</span> <span class="o">!=</span> <span class="n">family_3dh</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;2D and 3D spaces do not match: </span><span class="si">{0:s}</span><span class="s1"> </span><span class="si">{1:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">family_2d</span><span class="p">,</span> <span class="n">family_3dh</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_hdiv_scaling</span> <span class="o">=</span> <span class="n">family_2d</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Raviart-Thomas&#39;</span><span class="p">,</span> <span class="s1">&#39;RTCF&#39;</span><span class="p">,</span> <span class="s1">&#39;Brezzi-Douglas-Marini&#39;</span><span class="p">,</span> <span class="s1">&#39;BDMCF&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_hdiv_scaling</span> <span class="ow">and</span> <span class="n">elem_height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;elem_height must be provided for HDiv spaces&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">elem_facet</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="s1">&#39;average&#39;</span><span class="p">],</span> <span class="s1">&#39;Unsupported elem_facet: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem_facet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elem_facet</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">),</span>
                               <span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="n">elem_facet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">ON_TOP</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">ON_BOTTOM</span>

        <span class="n">out_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">elem_facet</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">out_nodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="n">out_nodes</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elem_facet</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
            <span class="c1"># compute average of top and bottom elem nodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                void my_kernel(double *func, double *func3d, int *idx) {</span>
<span class="s2">                    int nnodes = </span><span class="si">%(nodes)d</span><span class="s2">;</span>
<span class="s2">                    for ( int d = 0; d &lt; nnodes; d++ ) {</span>
<span class="s2">                        for ( int c = 0; c &lt; </span><span class="si">%(func2d_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                            func[</span><span class="si">%(func2d_dim)d</span><span class="s2">*d + c] = 0.5*(func3d[</span><span class="si">%(func3d_dim)d</span><span class="s2">*idx[d] + c] +</span>
<span class="s2">                                              func3d[</span><span class="si">%(func3d_dim)d</span><span class="s2">*idx[d + nnodes] + c]);</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span><span class="o">.</span><span class="n">arity</span><span class="p">,</span>
                        <span class="s1">&#39;func2d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                        <span class="s1">&#39;func3d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">value_size</span><span class="p">},</span>
                <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                void my_kernel(double *func, double *func3d, int *idx) {</span>
<span class="s2">                    for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                        for ( int c = 0; c &lt; </span><span class="si">%(func2d_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                            func[</span><span class="si">%(func2d_dim)d</span><span class="s2">*d + c] = func3d[</span><span class="si">%(func3d_dim)d</span><span class="s2">*idx[d] + c];</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span><span class="o">.</span><span class="n">arity</span><span class="p">,</span>
                        <span class="s1">&#39;func2d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                        <span class="s1">&#39;func3d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">value_size</span><span class="p">},</span>
                <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_hdiv_scaling</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="p">)</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span><span class="o">/</span><span class="n">elem_height</span><span class="o">*</span><span class="n">dx</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rt_scale_solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span>
                <span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="SubFunctionExtractor.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.SubFunctionExtractor.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">timed_stage</span><span class="p">(</span><span class="s1">&#39;copy_3d_to_2d&#39;</span><span class="p">):</span>
            <span class="c1"># execute par loop</span>
            <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">output_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">input_3d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
                         <span class="n">iterate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_domain</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_hdiv_scaling</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rt_scale_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="ALEMeshUpdater"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.ALEMeshUpdater">[docs]</a><span class="k">class</span> <span class="nc">ALEMeshUpdater</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that handles vertically moving ALE mesh</span>

<span class="sd">    Mesh geometry is updated to match the elevation field</span>
<span class="sd">    (``solver.fields.elev_2d``). First the discontinuous elevation field is</span>
<span class="sd">    projected to continuous space, and this field is used to update the mesh</span>
<span class="sd">    coordinates.</span>

<span class="sd">    This class stores the reference coordinate field and keeps track of the</span>
<span class="sd">    updated mesh coordinates. It also provides a method for computing the mesh</span>
<span class="sd">    velocity from two adjacent elevation fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver: :class:`FlowSolver` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">fields</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_ale_moving_mesh</span><span class="p">:</span>
            <span class="c1"># continous elevation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elev_cg_2d</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">function_spaces</span><span class="o">.</span><span class="n">P1_2d</span><span class="p">,</span>
                                       <span class="n">name</span><span class="o">=</span><span class="s1">&#39;elev cg 2d&#39;</span><span class="p">)</span>
            <span class="c1"># w_mesh at surface</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w mesh surf 2d&#39;</span><span class="p">)</span>
            <span class="c1"># elevation in coordinate space</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_to_cg_2d</span> <span class="o">=</span> <span class="n">Projector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_2d</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_cg_to_coords_2d</span> <span class="o">=</span> <span class="n">Projector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cp_v_elem_size_to_2d</span> <span class="o">=</span> <span class="n">SubFunctionExtractor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">v_elem_size_3d</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">v_elem_size_2d</span><span class="p">,</span>
                                                         <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">elem_facet</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_ref_3d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>

        <span class="n">family_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
        <span class="n">base_element_3d</span> <span class="o">=</span> <span class="n">get_extruded_base_element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_element_3d</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TensorProductElement</span><span class="p">)</span>
        <span class="n">family_3dh</span> <span class="o">=</span> <span class="n">base_element_3d</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">family</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">family_2d</span> <span class="o">!=</span> <span class="n">family_3dh</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;2D and 3D spaces do not match: &quot;</span><span class="si">{0:s}</span><span class="s1">&quot; != &quot;</span><span class="si">{1:s}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">family_2d</span><span class="p">,</span> <span class="n">family_3dh</span><span class="p">))</span>

        <span class="c1"># number of nodes in vertical direction</span>
        <span class="n">n_vert_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">()</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">get_facet_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Global</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;node_idx&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_z_coord</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            void my_kernel(double *z_coord_3d, double *z_ref_3d, double *elev_2d, double *bath_2d, int *idx) {</span>
<span class="s2">                for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                    for ( int c = 0; c &lt; </span><span class="si">%(func2d_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                        for ( int e = 0; e &lt; </span><span class="si">%(v_nodes)d</span><span class="s2">; e++ ) {</span>
<span class="s2">                            double eta = elev_2d[</span><span class="si">%(func2d_dim)d</span><span class="s2">*d + c];</span>
<span class="s2">                            double bath = bath_2d[</span><span class="si">%(func2d_dim)d</span><span class="s2">*d + c];</span>
<span class="s2">                            double z_ref = z_ref_3d[</span><span class="si">%(func3d_dim)d</span><span class="s2">*(idx[d]+e) + c];</span>
<span class="s2">                            double new_z = eta*(z_ref + bath)/bath + z_ref;</span>
<span class="s2">                            z_coord_3d[</span><span class="si">%(func3d_dim)d</span><span class="s2">*(idx[d]+e) + c] = new_z;</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }</span>
<span class="s2">            }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">(),</span>
                    <span class="s1">&#39;func2d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                    <span class="s1">&#39;func3d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                    <span class="s1">&#39;v_nodes&#39;</span><span class="p">:</span> <span class="n">n_vert_nodes</span><span class="p">},</span>
            <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_w_mesh</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            void my_kernel(double *w_mesh_3d, double *z_ref_3d, double *w_mesh_surf_2d, double *bath_2d, int *idx) {</span>
<span class="s2">                for ( int d = 0; d &lt; </span><span class="si">%(nodes)d</span><span class="s2">; d++ ) {</span>
<span class="s2">                    for ( int c = 0; c &lt; </span><span class="si">%(func2d_dim)d</span><span class="s2">; c++ ) {</span>
<span class="s2">                        for ( int e = 0; e &lt; </span><span class="si">%(v_nodes)d</span><span class="s2">; e++ ) {</span>
<span class="s2">                            double w_mesh_surf = w_mesh_surf_2d[</span><span class="si">%(func2d_dim)d</span><span class="s2">*d + c];</span>
<span class="s2">                            double bath = bath_2d[</span><span class="si">%(func2d_dim)d</span><span class="s2">*d + c];</span>
<span class="s2">                            double z_ref = z_ref_3d[</span><span class="si">%(func3d_dim)d</span><span class="s2">*(idx[d]+e) + c];</span>
<span class="s2">                            double new_w = w_mesh_surf * (z_ref + bath)/bath;</span>
<span class="s2">                            w_mesh_3d[</span><span class="si">%(func3d_dim)d</span><span class="s2">*(idx[d]+e) + c] = new_w;</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }</span>
<span class="s2">            }&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">finat_element</span><span class="o">.</span><span class="n">space_dimension</span><span class="p">(),</span>
                    <span class="s1">&#39;func2d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                    <span class="s1">&#39;func3d_dim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span>
                    <span class="s1">&#39;v_nodes&#39;</span><span class="p">:</span> <span class="n">n_vert_nodes</span><span class="p">},</span>
            <span class="s1">&#39;my_kernel&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ALEMeshUpdater.initialize"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.ALEMeshUpdater.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set values for initial mesh (elevation at rest)&quot;&quot;&quot;</span>
        <span class="n">get_zcoord_from_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_ref_3d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_3d</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_ref_3d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_elem_height</span><span class="p">()</span></div>

<div class="viewcode-block" id="ALEMeshUpdater.update_elem_height"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.ALEMeshUpdater.update_elem_height">[docs]</a>    <span class="k">def</span> <span class="nf">update_elem_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates vertical element size fields&quot;&quot;&quot;</span>
        <span class="n">compute_elem_height</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_3d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">v_elem_size_3d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cp_v_elem_size_to_2d</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>

<div class="viewcode-block" id="ALEMeshUpdater.compute_mesh_velocity_begin"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.ALEMeshUpdater.compute_mesh_velocity_begin">[docs]</a>    <span class="k">def</span> <span class="nf">compute_mesh_velocity_begin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stores the current 2D elevation state as the &quot;old&quot; field&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_ale_moving_mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_to_cg_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_cg_to_coords_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span></div>

<div class="viewcode-block" id="ALEMeshUpdater.compute_mesh_velocity_finalize"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.ALEMeshUpdater.compute_mesh_velocity_finalize">[docs]</a>    <span class="k">def</span> <span class="nf">compute_mesh_velocity_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">w_mesh_surf_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes mesh velocity from the elevation difference</span>

<span class="sd">        Stores the current 2D elevation state as the &quot;new&quot; field,</span>
<span class="sd">        and computes w_mesh using the given time step factor ``c``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_ale_moving_mesh</span>
        <span class="c1"># compute w_mesh at surface</span>
        <span class="k">if</span> <span class="n">w_mesh_surf_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default formulation</span>
            <span class="c1"># w_mesh_surf = (elev_new - elev_old)/dt/c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_to_cg_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_cg_to_coords_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># user-defined formulation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">w_mesh_surf_expr</span><span class="p">)</span>
        <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel_w_mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">w_mesh_3d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_ref_3d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_mesh_surf_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
            <span class="n">iterate</span><span class="o">=</span><span class="n">op2</span><span class="o">.</span><span class="n">ALL</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ALEMeshUpdater.update_mesh_coordinates"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.ALEMeshUpdater.update_mesh_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">update_mesh_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates 3D mesh coordinates to match current elev_2d field</span>

<span class="sd">        elev_2d is first projected to continous space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_ale_moving_mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_to_cg_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_elev_cg_to_coords_2d</span><span class="o">.</span><span class="n">project</span><span class="p">()</span>

        <span class="c1"># compute new z coordinates -&gt; self.fields.z_coord_3d</span>
        <span class="n">op2</span><span class="o">.</span><span class="n">par_loop</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel_z_coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span><span class="o">.</span><span class="n">cell_set</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_3d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">WRITE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_ref_3d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_3d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_2d</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">(</span><span class="n">op2</span><span class="o">.</span><span class="n">READ</span><span class="p">),</span>
            <span class="n">iterate</span><span class="o">=</span><span class="n">op2</span><span class="o">.</span><span class="n">ALL</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">z_coord_3d</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_elem_height</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">clear_spatial_index</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="SmagorinskyViscosity"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.SmagorinskyViscosity">[docs]</a><span class="k">class</span> <span class="nc">SmagorinskyViscosity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes Smagorinsky subgrid scale horizontal viscosity</span>

<span class="sd">    This formulation is according to Ilicak et al. (2012) and</span>
<span class="sd">    Griffies and Hallberg (2000).</span>

<span class="sd">    .. math::</span>
<span class="sd">        \nu = (C_s \Delta x)^2 |S|</span>

<span class="sd">    with the deformation rate</span>

<span class="sd">    .. math::</span>
<span class="sd">        |S| &amp;= \sqrt{D_T^2 + D_S^2} \\</span>
<span class="sd">        D_T &amp;= \frac{\partial u}{\partial x} - \frac{\partial v}{\partial y} \\</span>
<span class="sd">        D_S &amp;= \frac{\partial u}{\partial y} + \frac{\partial v}{\partial x}</span>

<span class="sd">    :math:`\Delta x` is the horizontal element size and :math:`C_s` is the</span>
<span class="sd">    Smagorinsky coefficient.</span>

<span class="sd">    To match a certain mesh Reynolds number :math:`Re_h` set</span>
<span class="sd">    :math:`C_s = 1/\sqrt{Re_h}`.</span>

<span class="sd">    Ilicak et al. (2012). Spurious dianeutral mixing and the role of</span>
<span class="sd">    momentum closure. Ocean Modelling, 45-46(0):37-58.</span>
<span class="sd">    http://dx.doi.org/10.1016/j.ocemod.2011.10.003</span>

<span class="sd">    Griffies and Hallberg (2000). Biharmonic friction with a</span>
<span class="sd">    Smagorinsky-like viscosity for use in large-scale eddy-permitting</span>
<span class="sd">    ocean models. Monthly Weather Review, 128(8):2935-2946.</span>
<span class="sd">    http://dx.doi.org/10.1175/1520-0493(2000)128%3C2935:BFWASL%3E2.0.CO;2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">c_s</span><span class="p">,</span> <span class="n">h_elem_size</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">min_val</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
                 <span class="n">weak_form</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg uv_3d: horizontal velocity</span>
<span class="sd">        :type uv_3d: 3D vector :class:`Function`</span>
<span class="sd">        :arg output: Smagorinsky viscosity field</span>
<span class="sd">        :type output: 3D scalar :class:`Function`</span>
<span class="sd">        :arg c_s: Smagorinsky coefficient</span>
<span class="sd">        :type c_s: float or :class:`Constant`</span>
<span class="sd">        :arg h_elem_size: field that defines the horizontal element size</span>
<span class="sd">        :type h_elem_size: 3D scalar :class:`Function` or :class:`Constant`</span>
<span class="sd">        :arg float max_val: Maximum allowed viscosity. Viscosity will be clipped at</span>
<span class="sd">            this value.</span>
<span class="sd">        :kwarg float min_val: Minimum allowed viscosity. Viscosity will be clipped at</span>
<span class="sd">            this value.</span>
<span class="sd">        :kwarg bool weak_form: Compute velocity shear by integrating by parts.</span>
<span class="sd">            Necessary for some function spaces (e.g. P0).</span>
<span class="sd">        :kwarg dict solver_parameters: PETSc solver options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">solver_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_atol&#39;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
        <span class="n">solver_parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ksp_rtol&#39;</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">max_val</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span> <span class="o">==</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">(),</span> \
            <span class="s1">&#39;max_val function must belong to the same space as output&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_val</span> <span class="o">=</span> <span class="n">max_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span> <span class="o">=</span> <span class="n">min_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weak_form</span> <span class="o">=</span> <span class="n">weak_form</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_form</span><span class="p">:</span>
            <span class="c1"># solve grad(u) weakly</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
            <span class="n">fs_grad</span> <span class="o">=</span> <span class="n">get_functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;DP&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;DP&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs_grad</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;uv_grad&#39;</span><span class="p">)</span>

            <span class="n">tri_grad</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs_grad</span><span class="p">)</span>
            <span class="n">test_grad</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs_grad</span><span class="p">)</span>

            <span class="n">normal</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">tri_grad</span><span class="p">,</span> <span class="n">test_grad</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

            <span class="n">rhs_terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">iuv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">iuv</span> <span class="o">+</span> <span class="n">ix</span>
                    <span class="n">vol_term</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">Dx</span><span class="p">(</span><span class="n">test_grad</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ix</span><span class="p">),</span> <span class="n">uv</span><span class="p">[</span><span class="n">iuv</span><span class="p">])</span><span class="o">*</span><span class="n">dx</span>
                    <span class="n">int_term</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">avg</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="n">iuv</span><span class="p">]),</span> <span class="n">jump</span><span class="p">(</span><span class="n">test_grad</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="n">ix</span><span class="p">]))</span><span class="o">*</span><span class="n">dS_v</span>
                    <span class="n">ext_term</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="n">iuv</span><span class="p">],</span> <span class="n">test_grad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span><span class="o">*</span><span class="n">ds_v</span>
                    <span class="n">rhs_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">vol_term</span><span class="p">,</span> <span class="n">int_term</span><span class="p">,</span> <span class="n">ext_term</span><span class="p">])</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rhs_terms</span><span class="p">)</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weak_grad_solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

            <span class="c1"># rate of strain tensor</span>
            <span class="n">d_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">d_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># rate of strain tensor</span>
            <span class="n">d_t</span> <span class="o">=</span> <span class="n">Dx</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">Dx</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">d_s</span> <span class="o">=</span> <span class="n">Dx</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Dx</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>

        <span class="n">nu</span> <span class="o">=</span> <span class="n">c_s</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">h_elem_size</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d_t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d_s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">test</span><span class="o">*</span><span class="n">tri</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">test</span><span class="o">*</span><span class="n">nu</span><span class="o">*</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="p">)</span>

<div class="viewcode-block" id="SmagorinskyViscosity.solve"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.SmagorinskyViscosity.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute viscosity&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_form</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weak_grad_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="c1"># remove negative values</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_val</span>

        <span class="c1"># crop too large values</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_val</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_val</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="EquationOfState"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.EquationOfState">[docs]</a><span class="k">class</span> <span class="nc">EquationOfState</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of all equation of state objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

<div class="viewcode-block" id="EquationOfState.compute_rho"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.EquationOfState.compute_rho">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">compute_rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sea water density.</span>

<span class="sd">        :arg s: Salinity expressed on the Practical Salinity Scale 1978</span>
<span class="sd">        :type s: float or numpy.array</span>
<span class="sd">        :arg th: Potential temperature in Celsius, referenced to pressure</span>
<span class="sd">            p_r = 0 dbar.</span>
<span class="sd">        :type th: float or numpy.array</span>
<span class="sd">        :arg p: Pressure in decibars (1 dbar = 1e4 Pa)</span>
<span class="sd">        :type p: float or numpy.array</span>
<span class="sd">        :kwarg float rho0: Optional reference density. If provided computes</span>
<span class="sd">            :math:`\rho&#39; = \rho(S, Th, p) - \rho_0`</span>
<span class="sd">        :return: water density</span>
<span class="sd">        :rtype: float or numpy.array</span>

<span class="sd">        All pressures are gauge pressures: they are the absolute pressures minus standard atmosperic</span>
<span class="sd">        pressure 10.1325 dbar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="EquationOfState.eval"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.EquationOfState.eval">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sea water density.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="JackettEquationOfState"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.JackettEquationOfState">[docs]</a><span class="k">class</span> <span class="nc">JackettEquationOfState</span><span class="p">(</span><span class="n">EquationOfState</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Equation of State according of Jackett et al. (2006) for computing sea</span>
<span class="sd">    water density.</span>

<span class="sd">    .. math ::</span>
<span class="sd">        \rho = \rho&#39;(T, S, p) + \rho_0</span>
<span class="sd">        :label: equation_of_state</span>

<span class="sd">    :math:`\rho&#39;(T, S, p)` is a nonlinear rational function.</span>

<span class="sd">    Jackett et al. (2006). Algorithms for Density, Potential Temperature,</span>
<span class="sd">    Conservative Temperature, and the Freezing Temperature of Seawater.</span>
<span class="sd">    Journal of Atmospheric and Oceanic Technology, 23(12):1709-1728.</span>
<span class="sd">    http://dx.doi.org/10.1175/JTECH1946.1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">9.9984085444849347e2</span><span class="p">,</span> <span class="mf">7.3471625860981584e0</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.3211231792841769e-2</span><span class="p">,</span>
                  <span class="mf">3.6492439109814549e-4</span><span class="p">,</span> <span class="mf">2.5880571023991390e0</span><span class="p">,</span> <span class="o">-</span><span class="mf">6.7168282786692355e-3</span><span class="p">,</span>
                  <span class="mf">1.9203202055760151e-3</span><span class="p">,</span> <span class="mf">1.1798263740430364e-2</span><span class="p">,</span> <span class="mf">9.8920219266399117e-8</span><span class="p">,</span>
                  <span class="mf">4.6996642771754730e-6</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5862187075154352e-8</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.2921414007960662e-12</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">7.2815210113327091e-3</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.4787265461983921e-5</span><span class="p">,</span> <span class="mf">3.3851002965802430e-7</span><span class="p">,</span>
                  <span class="mf">1.3651202389758572e-10</span><span class="p">,</span> <span class="mf">1.7632126669040377e-3</span><span class="p">,</span> <span class="o">-</span><span class="mf">8.8066583251206474e-6</span><span class="p">,</span>
                  <span class="o">-</span><span class="mf">1.8832689434804897e-10</span><span class="p">,</span> <span class="mf">5.7463776745432097e-6</span><span class="p">,</span> <span class="mf">1.4716275472242334e-9</span><span class="p">,</span>
                  <span class="mf">6.7103246285651894e-6</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4461698007024582e-17</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.1534417604289062e-18</span><span class="p">])</span>

<div class="viewcode-block" id="JackettEquationOfState.compute_rho"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.JackettEquationOfState.compute_rho">[docs]</a>    <span class="k">def</span> <span class="nf">compute_rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sea water density.</span>

<span class="sd">        :arg s: Salinity expressed on the Practical Salinity Scale 1978</span>
<span class="sd">        :type s: float or numpy.array</span>
<span class="sd">        :arg th: Potential temperature in Celsius, referenced to pressure</span>
<span class="sd">            p_r = 0 dbar.</span>
<span class="sd">        :type th: float or numpy.array</span>
<span class="sd">        :arg p: Pressure in decibars (1 dbar = 1e4 Pa)</span>
<span class="sd">        :type p: float or numpy.array</span>
<span class="sd">        :kwarg float rho0: Optional reference density. If provided computes</span>
<span class="sd">            :math:`\rho&#39; = \rho(S, Th, p) - \rho_0`</span>
<span class="sd">        :return: water density</span>
<span class="sd">        :rtype: float or numpy.array</span>

<span class="sd">        All pressures are gauge pressures: they are the absolute pressures minus standard atmosperic</span>
<span class="sd">        pressure 10.1325 dbar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>  <span class="c1"># ensure salinity is positive</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">s_pos</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="p">)</span></div>

<div class="viewcode-block" id="JackettEquationOfState.eval"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.JackettEquationOfState.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
        <span class="n">pn</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
              <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">th</span> <span class="o">*</span> <span class="n">th</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
              <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
              <span class="o">+</span> <span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
              <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
              <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">th</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">pn</span><span class="o">/</span><span class="n">pd</span> <span class="o">-</span> <span class="n">rho0</span>
        <span class="k">return</span> <span class="n">rho</span></div></div>


<div class="viewcode-block" id="LinearEquationOfState"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.LinearEquationOfState">[docs]</a><span class="k">class</span> <span class="nc">LinearEquationOfState</span><span class="p">(</span><span class="n">EquationOfState</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear Equation of State for computing sea water density</span>

<span class="sd">    .. math::</span>
<span class="sd">        \rho = \rho_{ref} - \alpha (T - T_{ref}) + \beta (S - S_{ref})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho_ref</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">th_ref</span><span class="p">,</span> <span class="n">s_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg float rho_ref: reference density</span>
<span class="sd">        :arg float alpha: thermal expansion coefficient</span>
<span class="sd">        :arg float beta: haline contraction coefficient</span>
<span class="sd">        :arg float th_ref: reference temperature</span>
<span class="sd">        :arg float s_ref: reference salinity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho_ref</span> <span class="o">=</span> <span class="n">rho_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">th_ref</span> <span class="o">=</span> <span class="n">th_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_ref</span> <span class="o">=</span> <span class="n">s_ref</span>

<div class="viewcode-block" id="LinearEquationOfState.compute_rho"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.LinearEquationOfState.compute_rho">[docs]</a>    <span class="k">def</span> <span class="nf">compute_rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sea water density.</span>

<span class="sd">        :arg s: Salinity expressed on the Practical Salinity Scale 1978</span>
<span class="sd">        :type s: float or numpy.array</span>
<span class="sd">        :arg th: Potential temperature in Celsius</span>
<span class="sd">        :type th: float or numpy.array</span>
<span class="sd">        :arg p: Pressure in decibars (1 dbar = 1e4 Pa)</span>
<span class="sd">        :type p: float or numpy.array</span>
<span class="sd">        :kwarg float rho0: Optional reference density. If provided computes</span>
<span class="sd">            :math:`\rho&#39; = \rho(S, Th, p) - \rho_0`</span>
<span class="sd">        :return: water density</span>
<span class="sd">        :rtype: float or numpy.array</span>

<span class="sd">        Pressure is ingored in this equation of state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho_ref</span> <span class="o">-</span> <span class="n">rho0</span>
               <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">th</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">th_ref</span><span class="p">)</span>
               <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">*</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ref</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rho</span></div>

<div class="viewcode-block" id="LinearEquationOfState.eval"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.LinearEquationOfState.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_rho</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="get_horizontal_elem_size_3d"><a class="viewcode-back" href="../../thetis.html#thetis.utility3d.get_horizontal_elem_size_3d">[docs]</a><span class="k">def</span> <span class="nf">get_horizontal_elem_size_3d</span><span class="p">(</span><span class="n">sol2d</span><span class="p">,</span> <span class="n">sol3d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes horizontal element size from the 2D mesh, then copies it on a 3D</span>
<span class="sd">    field</span>

<span class="sd">    :arg sol2d: 2D :class:`Function` for the element size field</span>
<span class="sd">    :arg sol3d: 3D :class:`Function` for the element size field</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">get_horizontal_elem_size_2d</span><span class="p">(</span><span class="n">sol2d</span><span class="p">)</span>
    <span class="n">ExpandFunctionTo3d</span><span class="p">(</span><span class="n">sol2d</span><span class="p">,</span> <span class="n">sol3d</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2020, Tuomas Karna et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>