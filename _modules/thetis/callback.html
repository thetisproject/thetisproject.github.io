
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>thetis.callback &#8212; Thetis 0+untagged.1718.gf836c9a.dirty documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/thetis.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<!-- <link rel="stylesheet" href="../../_static/featured.css"> -->


<link rel="shortcut icon" href="../../_static/icon_thetis.ico" />


  </head><body>
<div class="wrapper">
  <a href="../../index.html"><img src="../../_static/banner.jpg" height="180px" alt="Thetis Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
        <li class="page_item"><a href="../../documentation.html" title="Thetis documentation">Documentation</a></li>
        <li class="page_item"><a href="../../download.html" title="Install Thetis">Download</a></li>
        <li class="page_item"><a href="../../team.html" title="Development team">Team</a></li>
        <li class="page_item"><a href="../../publications.html" title="Publications">Publications</a></li>
        <li class="page_item"><a href="../../funding.html" title="Our financial supporters">Funding</a></li>
        <li class="page_item"><a href="../../contact.html" title="Getting in touch">Contact</a></li>
        <li class="page_item"><a href="https://github.com/thetisproject/thetis" title="Thetis source on GitHub">GitHub</a></li>
        <li class="page_item"><a href="https://jenkins.ese.ic.ac.uk:1080/blue/organizations/jenkins/thetis/branches" title="Thetis build status">Jenkins</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="_modules/thetis/callback">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for thetis.callback</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines custom callback functions used to compute various metrics at runtime.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">.utility</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">.log</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="o">*</span>


<div class="viewcode-block" id="CallbackManager"><a class="viewcode-back" href="../../thetis.html#thetis.callback.CallbackManager">[docs]</a><span class="k">class</span> <span class="nc">CallbackManager</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores callbacks in different categories and provides methods for</span>
<span class="sd">    evaluating them.</span>

<span class="sd">    Create callbacks and register them under ``&#39;export&#39;`` mode</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        cb1 = VolumeConservation3DCallback(...)</span>
<span class="sd">        cb2 = TracerMassConservationCallback(...)</span>
<span class="sd">        cm = CallbackManager()</span>
<span class="sd">        cm.add(cb1, &#39;export&#39;)</span>
<span class="sd">        cm.add(cb2, &#39;export&#39;)</span>

<span class="sd">    Evaluate callbacks, calls :func:`evaluate` method of all callbacks</span>
<span class="sd">    registered in the given mode.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        cm.evaluate(&#39;export&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CallbackManager</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">)</span>

<div class="viewcode-block" id="CallbackManager.add"><a class="viewcode-back" href="../../thetis.html#thetis.callback.CallbackManager.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a callback under the given mode</span>

<span class="sd">        :arg callback: a :class:`.DiagnosticCallback` object</span>
<span class="sd">        :arg str mode: register callback under this mode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">callback</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback</span></div>

<div class="viewcode-block" id="CallbackManager.evaluate"><a class="viewcode-back" href="../../thetis.html#thetis.callback.CallbackManager.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate all callbacks registered under the given mode</span>

<span class="sd">        :arg str mode: evaluate all callbacks under this mode</span>
<span class="sd">        :kwarg int index: if provided, sets the export index. Default behavior</span>
<span class="sd">            is to append to the file or stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">mode</span><span class="p">]):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DiagnosticHDF5"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DiagnosticHDF5">[docs]</a><span class="k">class</span> <span class="nc">DiagnosticHDF5</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A HDF5 file for storing diagnostic time series arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">varnames</span><span class="p">,</span> <span class="n">array_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">comm</span><span class="o">=</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">new_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span>
                 <span class="n">include_time</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg str filename: Full filename of the HDF5 file.</span>
<span class="sd">        :arg varnames: List of variable names that the diagnostic callback</span>
<span class="sd">            provides</span>
<span class="sd">        :kwarg array_dim: Dimension of the output array.</span>
<span class="sd">            Can be a tuple for multi-dimensional output. Use &quot;1&quot; for scalars.</span>
<span class="sd">        :kwarg dict attrs: Additional attributes to be saved in the hdf5 file.</span>
<span class="sd">        :kwarg comm: MPI communicator</span>
<span class="sd">        :kwarg bool new_file: Define whether to create a new hdf5 file or</span>
<span class="sd">            append to an existing one (if any)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">comm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varnames</span> <span class="o">=</span> <span class="n">varnames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nvars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_dim</span> <span class="o">=</span> <span class="n">array_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_time</span> <span class="o">=</span> <span class="n">include_time</span>
        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">new_file</span><span class="p">:</span>
            <span class="c1"># create empty file with correct datasets</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf5file</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">include_time</span><span class="p">:</span>
                    <span class="n">hdf5file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                            <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">dim_list</span> <span class="o">=</span> <span class="n">array_dim</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">dim_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dim_list</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">dim_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">dim_list</span><span class="p">])</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dim_list</span><span class="p">)</span>
                <span class="n">max_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">dim_list</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">varnames</span><span class="p">:</span>
                    <span class="n">hdf5file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
                                            <span class="n">maxshape</span><span class="o">=</span><span class="n">max_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">hdf5file</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf5file</span><span class="p">,</span> <span class="n">varname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expands array varname by 1 entry&quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">hdf5file</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf5file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expands data arrays by 1 entry&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">varnames</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_array</span><span class="p">(</span><span class="n">hdf5file</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_time</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_array</span><span class="p">(</span><span class="n">hdf5file</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_nentries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf5file</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">hdf5file</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">varnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="DiagnosticHDF5.export"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DiagnosticHDF5.export">[docs]</a>    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends a new entry of (time, variables) to the file.</span>

<span class="sd">        The HDF5 is updated immediately.</span>

<span class="sd">        :arg time: time stamp of entry</span>
<span class="sd">        :type time: float</span>
<span class="sd">        :arg variables: values of entry</span>
<span class="sd">        :type variables: tuple of float</span>
<span class="sd">        :kwarg int index: If provided, defines the time index in the file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf5file</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nentries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nentries</span><span class="p">(</span><span class="n">hdf5file</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="n">nentries</span><span class="p">,</span> <span class="s1">&#39;time index out of range </span><span class="si">{:}</span><span class="s1"> &lt;= </span><span class="si">{:}</span><span class="s1"> </span><span class="se">\n</span><span class="s1">  in file </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">nentries</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                    <span class="n">expand_required</span> <span class="o">=</span> <span class="n">index</span> <span class="o">==</span> <span class="n">nentries</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="n">index</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">expand_required</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">hdf5file</span><span class="p">)</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nentries</span><span class="p">(</span><span class="n">hdf5file</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_time</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;time should be provided as 2nd argument to export()&#39;</span>
                    <span class="n">hdf5file</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nvars</span><span class="p">):</span>
                    <span class="n">hdf5file</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">varnames</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">hdf5file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="DiagnosticCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DiagnosticCallback">[docs]</a><span class="k">class</span> <span class="nc">DiagnosticCallback</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class for all Callback classes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="n">array_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">outputdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">export_to_hdf5</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">append_to_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">include_time</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">hdf5_dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :kwarg str outputdir: Custom directory where hdf5 files will be stored.</span>
<span class="sd">            By default solver&#39;s output directory is used.</span>
<span class="sd">        :kwarg array_dim: Dimension of the output array.</span>
<span class="sd">            Can be a tuple for multi-dimensional output. Use &quot;1&quot; for scalars.</span>
<span class="sd">        :kwarg dict attrs: Additional attributes to be saved in the hdf5 file.</span>
<span class="sd">        :kwarg bool export_to_hdf5: If True, diagnostics will be stored in hdf5</span>
<span class="sd">            format</span>
<span class="sd">        :kwarg bool append_to_log: If True, callback output messages will be</span>
<span class="sd">            printed in log</span>
<span class="sd">        :kwarg bool include_time: whether to include time in the hdf5 file</span>
<span class="sd">        :kwarg hdf5_dtype: Precision to use in hdf5 output: `d` for double</span>
<span class="sd">            precision (default), and `f` for single precision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span> <span class="o">=</span> <span class="n">solver_obj</span>
        <span class="k">if</span> <span class="n">outputdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">output_directory</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span> <span class="o">=</span> <span class="n">outputdir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_dim</span> <span class="o">=</span> <span class="n">array_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">attrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_to_hdf5</span> <span class="o">=</span> <span class="n">export_to_hdf5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_to_log</span> <span class="o">=</span> <span class="n">append_to_log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdf5_dtype</span> <span class="o">=</span> <span class="n">hdf5_dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_time</span> <span class="o">=</span> <span class="n">include_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_new_file</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hdf5_initialized</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="DiagnosticCallback.set_write_mode"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DiagnosticCallback.set_write_mode">[docs]</a>    <span class="k">def</span> <span class="nf">set_write_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define whether to create a new hdf5 file or append to an existing one</span>

<span class="sd">        :arg str mode: Either &#39;create&#39; (default) or &#39;append&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;create&#39;</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_new_file</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;create&#39;</span></div>

    <span class="k">def</span> <span class="nf">_create_hdf5_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an empty hdf5 file with correct datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">append_to_hdf5</span><span class="p">:</span>
            <span class="n">comm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">comm</span>
            <span class="n">create_directory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;diagnostic_</span><span class="si">{:}</span><span class="s1">.hdf5&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">))</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdf_exporter</span> <span class="o">=</span> <span class="n">DiagnosticHDF5</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_names</span><span class="p">,</span>
                                               <span class="n">array_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array_dim</span><span class="p">,</span>
                                               <span class="n">new_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_new_file</span><span class="p">,</span>
                                               <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                                               <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf5_dtype</span><span class="p">,</span>
                                               <span class="n">include_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hdf5_initialized</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the diagnostic&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">variable_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Names of all scalar values&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the diagnostic value.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method must implement all MPI reduction operations (if any).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="DiagnosticCallback.message_str"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DiagnosticCallback.message_str">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">message_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string representation.</span>

<span class="sd">        :arg args: If provided, these will be the return value from</span>
<span class="sd">            :meth:`__call__`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> diagnostic&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiagnosticCallback.push_to_log"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DiagnosticCallback.push_to_log">[docs]</a>    <span class="k">def</span> <span class="nf">push_to_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Push callback status message to log</span>

<span class="sd">        :arg time: time stamp of entry</span>
<span class="sd">        :arg args: the return value from :meth:`__call__`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">print_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message_str</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span></div>

<div class="viewcode-block" id="DiagnosticCallback.push_to_hdf5"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DiagnosticCallback.push_to_hdf5">[docs]</a>    <span class="k">def</span> <span class="nf">push_to_hdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append values to HDF5 file.</span>

<span class="sd">        :arg time: time stamp of entry</span>
<span class="sd">        :arg args: the return value from :meth:`__call__`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hdf5_initialized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_hdf5_file</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdf_exporter</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiagnosticCallback.evaluate"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DiagnosticCallback.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates callback and pushes values to log and hdf file (if enabled)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">()</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">simulation_time</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">append_to_log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_to_log</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">append_to_hdf5</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_to_hdf5</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ScalarConservationCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.ScalarConservationCallback">[docs]</a><span class="k">class</span> <span class="nc">ScalarConservationCallback</span><span class="p">(</span><span class="n">DiagnosticCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for callbacks that check conservation of a scalar quantity&quot;&quot;&quot;</span>
    <span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;integral&#39;</span><span class="p">,</span> <span class="s1">&#39;relative_difference&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar_callback</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates scalar conservation check callback object</span>

<span class="sd">        :arg scalar_callback: Python function that takes the solver object as</span>
<span class="sd">            an argument and returns a scalar quantity of interest</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see</span>
<span class="sd">            :class:`.DiagnosticCallback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ScalarConservationCallback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalar_callback</span> <span class="o">=</span> <span class="n">scalar_callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar_callback</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">rel_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="n">rel_diff</span>

<div class="viewcode-block" id="ScalarConservationCallback.message_str"><a class="viewcode-back" href="../../thetis.html#thetis.callback.ScalarConservationCallback.message_str">[docs]</a>    <span class="k">def</span> <span class="nf">message_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:s}</span><span class="s1"> rel. error </span><span class="si">{1:11.4e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">line</span></div></div>


<div class="viewcode-block" id="VolumeConservation3DCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.VolumeConservation3DCallback">[docs]</a><span class="k">class</span> <span class="nc">VolumeConservation3DCallback</span><span class="p">(</span><span class="n">ScalarConservationCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks conservation of 3D volume (volume of 3D mesh)&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;volume3d&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see</span>
<span class="sd">            :class:`.DiagnosticCallback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">vol3d</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">comp_volume_3d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">VolumeConservation3DCallback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">vol3d</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="VolumeConservation2DCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.VolumeConservation2DCallback">[docs]</a><span class="k">class</span> <span class="nc">VolumeConservation2DCallback</span><span class="p">(</span><span class="n">ScalarConservationCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks conservation of 2D volume (integral of water elevation field)&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;volume2d&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see</span>
<span class="sd">            :class:`.DiagnosticCallback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">vol2d</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">comp_volume_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_2d</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_2d</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">VolumeConservation2DCallback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">vol2d</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TracerMassConservation2DCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.TracerMassConservation2DCallback">[docs]</a><span class="k">class</span> <span class="nc">TracerMassConservation2DCallback</span><span class="p">(</span><span class="n">ScalarConservationCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks conservation of depth-averaged tracer mass</span>

<span class="sd">    Depth-averaged tracer mass is defined as the integral of 2D tracer</span>
<span class="sd">    multiplied by total depth.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;tracer mass&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer_name</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg tracer_name: Name of the tracer. Use canonical field names as in</span>
<span class="sd">            :class:`.FieldDict`.</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see</span>
<span class="sd">            :class:`.DiagnosticCallback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tracer_name</span> <span class="o">+</span> <span class="s1">&#39; mass&#39;</span>  <span class="c1"># override name for given tracer</span>

        <span class="k">def</span> <span class="nf">mass</span><span class="p">():</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">solver_obj</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_2d</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">comp_tracer_mass_2d</span><span class="p">(</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">tracer_name</span><span class="p">],</span> <span class="n">H</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TracerMassConservation2DCallback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConservativeTracerMassConservation2DCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.ConservativeTracerMassConservation2DCallback">[docs]</a><span class="k">class</span> <span class="nc">ConservativeTracerMassConservation2DCallback</span><span class="p">(</span><span class="n">ScalarConservationCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks conservation of conservative tracer mass which is depth integrated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;tracer mass&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer_name</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg tracer_name: Name of the tracer. Use canonical field names as in</span>
<span class="sd">            :class:`.FieldDict`.</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see</span>
<span class="sd">            :class:`.DiagnosticCallback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tracer_name</span> <span class="o">+</span> <span class="s1">&#39; mass&#39;</span>  <span class="c1"># override name for given tracer</span>

        <span class="k">def</span> <span class="nf">mass</span><span class="p">():</span>
            <span class="c1"># tracer is depth-integrated already, so just integrate over domain</span>
            <span class="k">return</span> <span class="n">assemble</span><span class="p">(</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">tracer_name</span><span class="p">]</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ConservativeTracerMassConservation2DCallback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TracerMassConservationCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.TracerMassConservationCallback">[docs]</a><span class="k">class</span> <span class="nc">TracerMassConservationCallback</span><span class="p">(</span><span class="n">ScalarConservationCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks conservation of total tracer mass&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;tracer mass&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer_name</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg tracer_name: Name of the tracer. Use canonical field names as in</span>
<span class="sd">            :class:`.FieldDict`.</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see</span>
<span class="sd">            :class:`.DiagnosticCallback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tracer_name</span> <span class="o">+</span> <span class="s1">&#39; mass&#39;</span>  <span class="c1"># override name for given tracer</span>

        <span class="k">def</span> <span class="nf">mass</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">comp_tracer_mass_3d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">tracer_name</span><span class="p">])</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TracerMassConservationCallback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MinMaxConservationCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.MinMaxConservationCallback">[docs]</a><span class="k">class</span> <span class="nc">MinMaxConservationCallback</span><span class="p">(</span><span class="n">DiagnosticCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for callbacks that check conservation of a minimum/maximum&quot;&quot;&quot;</span>
    <span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;min_value&#39;</span><span class="p">,</span> <span class="s1">&#39;max_value&#39;</span><span class="p">,</span> <span class="s1">&#39;undershoot&#39;</span><span class="p">,</span> <span class="s1">&#39;overshoot&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minmax_callback</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg minmax_callback: Python function that takes the solver object as</span>
<span class="sd">            an argument and returns a (min, max) value tuple</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see</span>
<span class="sd">            :class:`.DiagnosticCallback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MinMaxConservationCallback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minmax_callback</span> <span class="o">=</span> <span class="n">minmax_callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minmax_callback</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">overshoot</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">undershoot</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">undershoot</span><span class="p">,</span> <span class="n">overshoot</span>

<div class="viewcode-block" id="MinMaxConservationCallback.message_str"><a class="viewcode-back" href="../../thetis.html#thetis.callback.MinMaxConservationCallback.message_str">[docs]</a>    <span class="k">def</span> <span class="nf">message_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:s}</span><span class="s1"> </span><span class="si">{1:g}</span><span class="s1"> </span><span class="si">{2:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">l</span></div></div>


<div class="viewcode-block" id="TracerOvershootCallBack"><a class="viewcode-back" href="../../thetis.html#thetis.callback.TracerOvershootCallBack">[docs]</a><span class="k">class</span> <span class="nc">TracerOvershootCallBack</span><span class="p">(</span><span class="n">MinMaxConservationCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks overshoots of the given tracer field.&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;tracer overshoot&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer_name</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg tracer_name: Name of the tracer. Use canonical field names as in</span>
<span class="sd">            :class:`.FieldDict`.</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see</span>
<span class="sd">            :class:`.DiagnosticCallback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tracer_name</span> <span class="o">+</span> <span class="s1">&#39; overshoot&#39;</span>

        <span class="k">def</span> <span class="nf">minmax</span><span class="p">():</span>
            <span class="n">tracer_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">tracer_name</span><span class="p">]</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">tracer_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">tracer_name</span><span class="p">]</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">tracer_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">tracer_min</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">MIN</span><span class="p">)</span>
            <span class="n">tracer_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">tracer_max</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">tracer_min</span><span class="p">,</span> <span class="n">tracer_max</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TracerOvershootCallBack</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">minmax</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="DetectorsCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DetectorsCallback">[docs]</a><span class="k">class</span> <span class="nc">DetectorsCallback</span><span class="p">(</span><span class="n">DiagnosticCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Callback that evaluates the specified fields at the specified locations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span>
                 <span class="n">detector_locations</span><span class="p">,</span>
                 <span class="n">field_names</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">,</span>
                 <span class="n">detector_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg detector_locations: List of x, y locations in which fields are to</span>
<span class="sd">            be interpolated.</span>
<span class="sd">        :arg field_names: List of fields to be interpolated.</span>
<span class="sd">        :arg name: Unique name for this callback and its associated set of</span>
<span class="sd">            detectors. This determines the name of the output h5 file</span>
<span class="sd">            (prefixed with `diagnostic_`).</span>
<span class="sd">        :arg detector_names: List of names for each of the detectors. If not</span>
<span class="sd">            provided automatic names of the form `detectorNNN` are created</span>
<span class="sd">            where NNN is the (0-padded) detector number.</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see</span>
<span class="sd">            :class:`.DiagnosticCallback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># printing all detector output to log is probably not a useful default:</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;append_to_log&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span>
                           <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">]</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># use null-padded ascii strings, dtype=&#39;U&#39; not supported in hdf5, see http://docs.h5py.org/en/latest/strings.html</span>
            <span class="s1">&#39;field_names&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">field_names</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">),</span>
            <span class="s1">&#39;field_dims&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_dims</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">solver_obj</span><span class="p">,</span> <span class="n">array_dim</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_dims</span><span class="p">),</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">ndetectors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">detector_locations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">detector_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ndetectors</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detector_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;detector{:0</span><span class="si">{fill}</span><span class="s1">d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndetectors</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ndetectors</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">detector_names</span><span class="p">),</span> <span class="s2">&quot;Different number of detector locations and names&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detector_names</span> <span class="o">=</span> <span class="n">detector_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detector_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detector_locations</span> <span class="o">=</span> <span class="n">detector_locations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_names</span> <span class="o">=</span> <span class="n">field_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variable_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">detector_names</span>

    <span class="k">def</span> <span class="nf">_values_per_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given all values evaulated in a detector location, return the values per field&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_dims</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">dim</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">dim</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="DetectorsCallback.message_str"><a class="viewcode-back" href="../../thetis.html#thetis.callback.DetectorsCallback.message_str">[docs]</a>    <span class="k">def</span> <span class="nf">message_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s1">&#39;In </span><span class="si">{}</span><span class="s1">: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">field_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_per_field</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detector_names</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_evaluate_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">detector_locations</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate all current fields in all detector locations</span>

<span class="sd">        Returns a ndetectors x ndims array, where ndims is the sum of the</span>
<span class="sd">        dimension of the fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndetectors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detector_locations</span><span class="p">)</span>
        <span class="n">field_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_names</span><span class="p">:</span>
            <span class="n">field_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_field</span><span class="p">(</span><span class="n">field_name</span><span class="p">),</span> <span class="p">(</span><span class="n">ndetectors</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">field_vals</span><span class="p">)</span></div>


<div class="viewcode-block" id="AccumulatorCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.AccumulatorCallback">[docs]</a><span class="k">class</span> <span class="nc">AccumulatorCallback</span><span class="p">(</span><span class="n">DiagnosticCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Callback that evaluates a (scalar) functional involving integrals in both</span>
<span class="sd">    time and space.</span>

<span class="sd">    This callback can also be used to assemble time dependent objective</span>
<span class="sd">    functionals for adjoint simulations. Time integration is achieved using</span>
<span class="sd">    the trapezium rule.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spatial integral at current timestep&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar_callback</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg scalar_callback: Python function that returns a list of values of an objective functional.</span>
<span class="sd">        :arg solver_obj: Thetis solver object</span>
<span class="sd">        :arg kwargs: any additional keyword arguments, see DiagnosticCallback</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;export_to_hdf5&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;append_to_log&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AccumulatorCallback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">solver_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalar_callback</span> <span class="o">=</span> <span class="n">scalar_callback</span>      <span class="c1"># Evaluate functional</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">solver_obj</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">timestep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrant</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_value</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">scalar_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar_callback</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrant</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_value</span> <span class="o">+</span> <span class="n">scalar_value</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_value</span> <span class="o">=</span> <span class="n">scalar_value</span>

        <span class="k">return</span> <span class="n">scalar_value</span>

<div class="viewcode-block" id="AccumulatorCallback.get_val"><a class="viewcode-back" href="../../thetis.html#thetis.callback.AccumulatorCallback.get_val">[docs]</a>    <span class="k">def</span> <span class="nf">get_val</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrant</span></div>

<div class="viewcode-block" id="AccumulatorCallback.message_str"><a class="viewcode-back" href="../../thetis.html#thetis.callback.AccumulatorCallback.message_str">[docs]</a>    <span class="k">def</span> <span class="nf">message_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:s}</span><span class="s1"> value </span><span class="si">{1:11.4e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">line</span></div></div>


<div class="viewcode-block" id="TimeSeriesCallback2D"><a class="viewcode-back" href="../../thetis.html#thetis.callback.TimeSeriesCallback2D">[docs]</a><span class="k">class</span> <span class="nc">TimeSeriesCallback2D</span><span class="p">(</span><span class="n">DiagnosticCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a time series of a 2D field at a given (x,y) location</span>

<span class="sd">    Currently implemented only for the 3D model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;timeseries&#39;</span>
    <span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="n">fieldnames</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                 <span class="n">location_name</span><span class="p">,</span>
                 <span class="n">outputdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">export_to_hdf5</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">append_to_log</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: Thetis :class:`FlowSolver` object</span>
<span class="sd">        :arg fieldnames: List of fields to extract</span>
<span class="sd">        :arg x, y: location coordinates in model coordinate system.</span>
<span class="sd">        :arg location_name: Unique name for this location. This</span>
<span class="sd">            determines the name of the output h5 file (prefixed with</span>
<span class="sd">            `diagnostic_`).</span>
<span class="sd">        :kwarg str outputdir: Custom directory where hdf5 files will be stored.</span>
<span class="sd">            By default solver&#39;s output directory is used.</span>
<span class="sd">        :kwarg bool export_to_hdf5: If True, diagnostics will be stored in hdf5</span>
<span class="sd">            format</span>
<span class="sd">        :kwarg bool append_to_log: If True, callback output messages will be</span>
<span class="sd">            printed in log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">export_to_hdf5</span> <span class="ow">is</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span> <span class="o">=</span> <span class="n">fieldnames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span> <span class="o">=</span> <span class="n">location_name</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span>
        <span class="n">field_short_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">]</span>
        <span class="n">field_str</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field_short_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_names</span> <span class="o">=</span> <span class="n">field_short_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">field_str</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TimeSeriesCallback2D</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">solver_obj</span><span class="p">,</span>
            <span class="n">outputdir</span><span class="o">=</span><span class="n">outputdir</span><span class="p">,</span>
            <span class="n">array_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
            <span class="n">export_to_hdf5</span><span class="o">=</span><span class="n">export_to_hdf5</span><span class="p">,</span>
            <span class="n">append_to_log</span><span class="o">=</span><span class="n">append_to_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span>
        <span class="k">if</span> <span class="n">outputdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">outputdir</span>

        <span class="c1"># test evaluation</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">at</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">PointNotInDomainError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Station &quot;</span><span class="si">{:}</span><span class="s1">&quot; out of horizontal domain&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># construct mesh points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="n">outvals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">))</span>
                <span class="n">outvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">PointNotInDomainError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Cannot evaluate data at station </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">))</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outvals</span><span class="p">)</span>

<div class="viewcode-block" id="TimeSeriesCallback2D.message_str"><a class="viewcode-back" href="../../thetis.html#thetis.callback.TimeSeriesCallback2D.message_str">[docs]</a>    <span class="k">def</span> <span class="nf">message_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s1">&#39;Evaluated </span><span class="si">{:}</span><span class="s1"> at </span><span class="si">{:}</span><span class="s1">: </span><span class="si">{:.3g}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">fieldname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># suppress last line break</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="TimeSeriesCallback3D"><a class="viewcode-back" href="../../thetis.html#thetis.callback.TimeSeriesCallback3D">[docs]</a><span class="k">class</span> <span class="nc">TimeSeriesCallback3D</span><span class="p">(</span><span class="n">DiagnosticCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a time series of a 3D field at a given (x,y,z) location</span>

<span class="sd">    Currently implemented only for the 3D model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;timeseries&#39;</span>
    <span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="n">fieldnames</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span>
                 <span class="n">location_name</span><span class="p">,</span>
                 <span class="n">outputdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">export_to_hdf5</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">append_to_log</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: Thetis :class:`FlowSolver` object</span>
<span class="sd">        :arg fieldnames: List of fields to extract</span>
<span class="sd">        :arg x, y, z: location coordinates in model coordinate system.</span>
<span class="sd">        :arg location_name: Unique name for this location. This</span>
<span class="sd">            determines the name of the output h5 file (prefixed with</span>
<span class="sd">            `diagnostic_`).</span>
<span class="sd">        :kwarg str outputdir: Custom directory where hdf5 files will be stored.</span>
<span class="sd">            By default solver&#39;s output directory is used.</span>
<span class="sd">        :kwarg bool export_to_hdf5: If True, diagnostics will be stored in hdf5</span>
<span class="sd">            format</span>
<span class="sd">        :kwarg bool append_to_log: If True, callback output messages will be</span>
<span class="sd">            printed in log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">export_to_hdf5</span> <span class="ow">is</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span> <span class="o">=</span> <span class="n">fieldnames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span> <span class="o">=</span> <span class="n">location_name</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">z</span><span class="p">}</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span>
        <span class="n">field_short_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">]</span>
        <span class="n">field_str</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field_short_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_names</span> <span class="o">=</span> <span class="n">field_short_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">field_str</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TimeSeriesCallback3D</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">solver_obj</span><span class="p">,</span>
            <span class="n">outputdir</span><span class="o">=</span><span class="n">outputdir</span><span class="p">,</span>
            <span class="n">array_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
            <span class="n">export_to_hdf5</span><span class="o">=</span><span class="n">export_to_hdf5</span><span class="p">,</span>
            <span class="n">append_to_log</span><span class="o">=</span><span class="n">append_to_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span>
        <span class="k">if</span> <span class="n">outputdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">outputdir</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">min_z</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">at</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">PointNotInDomainError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Station &quot;</span><span class="si">{:}</span><span class="s1">&quot; out of horizontal domain&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">e</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">min_z</span><span class="p">:</span>
            <span class="n">new_z</span> <span class="o">=</span> <span class="n">min_z</span> <span class="o">+</span> <span class="mf">0.1</span>
            <span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Water depth too shallow at </span><span class="si">{:}</span><span class="s1">; replacing z=</span><span class="si">{:}</span><span class="s1"> by z=</span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">new_z</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">new_z</span>

        <span class="c1"># construct mesh points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="n">outvals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">))</span>
                <span class="n">outvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">PointNotInDomainError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Cannot evaluate data at station </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">))</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outvals</span><span class="p">)</span>

<div class="viewcode-block" id="TimeSeriesCallback3D.message_str"><a class="viewcode-back" href="../../thetis.html#thetis.callback.TimeSeriesCallback3D.message_str">[docs]</a>    <span class="k">def</span> <span class="nf">message_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s1">&#39;Evaluated </span><span class="si">{:}</span><span class="s1"> at </span><span class="si">{:}</span><span class="s1"> </span><span class="si">{:.2f}</span><span class="s1"> m: </span><span class="si">{:.3g}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">fieldname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># suppress last line break</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="VerticalProfileCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.VerticalProfileCallback">[docs]</a><span class="k">class</span> <span class="nc">VerticalProfileCallback</span><span class="p">(</span><span class="n">DiagnosticCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a vertical profile of a 3D field at a given (x,y) location</span>

<span class="sd">    Only for the 3D model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;vertprofile&#39;</span>
    <span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;z_coord&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="n">fieldnames</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                 <span class="n">location_name</span><span class="p">,</span>
                 <span class="n">npoints</span><span class="o">=</span><span class="mi">48</span><span class="p">,</span>
                 <span class="n">outputdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">export_to_hdf5</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">append_to_log</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: Thetis :class:`FlowSolver` object</span>
<span class="sd">        :arg fieldnames: List of fields to extract</span>
<span class="sd">        :arg x, y: location coordinates in model coordinate system.</span>
<span class="sd">        :arg location_name: Unique name for this location. This</span>
<span class="sd">            determines the name of the output h5 file (prefixed with</span>
<span class="sd">            `diagnostic_`).</span>
<span class="sd">        :arg int npoints: Number of points along the vertical axis. The 3D</span>
<span class="sd">            field will be interpolated on these points, ranging from the bottom</span>
<span class="sd">            to the (time dependent) free surface.</span>
<span class="sd">        :kwarg str outputdir: Custom directory where hdf5 files will be stored.</span>
<span class="sd">            By default solver&#39;s output directory is used.</span>
<span class="sd">        :kwarg bool export_to_hdf5: If True, diagnostics will be stored in hdf5</span>
<span class="sd">            format</span>
<span class="sd">        :kwarg bool append_to_log: If True, callback output messages will be</span>
<span class="sd">            printed in log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">export_to_hdf5</span> <span class="ow">is</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span> <span class="o">=</span> <span class="n">fieldnames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span> <span class="o">=</span> <span class="n">location_name</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span>
        <span class="n">field_short_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">]</span>
        <span class="n">field_str</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field_short_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;z_coord&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">field_short_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">field_str</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">VerticalProfileCallback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">solver_obj</span><span class="p">,</span>
            <span class="n">outputdir</span><span class="o">=</span><span class="n">outputdir</span><span class="p">,</span>
            <span class="n">array_dim</span><span class="o">=</span><span class="n">npoints</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
            <span class="n">export_to_hdf5</span><span class="o">=</span><span class="n">export_to_hdf5</span><span class="p">,</span>
            <span class="n">append_to_log</span><span class="o">=</span><span class="n">append_to_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="n">npoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npoints</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-2</span>  <span class="c1"># nudge points to avoid libspatialindex errors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span>
        <span class="k">if</span> <span class="n">outputdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">outputdir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_construct_z_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># construct mesh points for func evaluation</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span>
            <span class="n">elev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">PointNotInDomainError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Station &quot;</span><span class="si">{:}</span><span class="s1">&quot; out of horizontal domain&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="n">z_min</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">)</span>
        <span class="n">z_max</span> <span class="o">=</span> <span class="n">elev</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_max</span> <span class="o">+</span> <span class="p">(</span><span class="n">z_min</span> <span class="o">-</span> <span class="n">z_max</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="c1"># update time-dependent z array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_z_array</span><span class="p">()</span>

        <span class="n">outvals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">))</span>
                <span class="n">outvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">PointNotInDomainError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Cannot evaluate data at station </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">))</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outvals</span><span class="p">)</span>

<div class="viewcode-block" id="VerticalProfileCallback.message_str"><a class="viewcode-back" href="../../thetis.html#thetis.callback.VerticalProfileCallback.message_str">[docs]</a>    <span class="k">def</span> <span class="nf">message_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">prof</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">minval</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">maxval</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s1">&#39;Evaluated </span><span class="si">{:}</span><span class="s1"> profile at </span><span class="si">{:}</span><span class="s1">: range </span><span class="si">{:.3g}</span><span class="s1"> - </span><span class="si">{:.3g}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">fieldname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># suppress last line break</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="TransectCallback"><a class="viewcode-back" href="../../thetis.html#thetis.callback.TransectCallback">[docs]</a><span class="k">class</span> <span class="nc">TransectCallback</span><span class="p">(</span><span class="n">DiagnosticCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a vertical transect of a 3D field at a given (x,y) locations.</span>

<span class="sd">    Only for the 3D model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;transect&#39;</span>
    <span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;z_coord&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="n">fieldnames</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                 <span class="n">location_name</span><span class="p">,</span>
                 <span class="n">n_points_z</span><span class="o">=</span><span class="mi">48</span><span class="p">,</span>
                 <span class="n">z_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">outputdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">export_to_hdf5</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">append_to_log</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg solver_obj: Thetis :class:`FlowSolver` object</span>
<span class="sd">        :arg fieldnames: List of fields to extract</span>
<span class="sd">        :arg x, y: location coordinates in model coordinate system.</span>
<span class="sd">        :arg location_name: Unique name for this location. This</span>
<span class="sd">            determines the name of the output h5 file (prefixed with</span>
<span class="sd">            `diagnostic_`).</span>
<span class="sd">        :arg int n_points_z: Number of points along the vertical axis. The 3D</span>
<span class="sd">            field will be interpolated on these points, ranging from the bottom</span>
<span class="sd">            to the (time dependent) free surface.</span>
<span class="sd">        :kwarg float z_min, zmax: Force min/max value of z coordinate extent.</span>
<span class="sd">            By default, transect will cover entire depth from bed to surface.</span>
<span class="sd">        :kwarg str outputdir: Custom directory where hdf5 files will be stored.</span>
<span class="sd">            By default solver&#39;s output directory is used.</span>
<span class="sd">        :kwarg bool export_to_hdf5: If True, diagnostics will be stored in hdf5</span>
<span class="sd">            format</span>
<span class="sd">        :kwarg bool append_to_log: If True, will print extracted min/max values</span>
<span class="sd">            of each field to log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">export_to_hdf5</span> <span class="ow">is</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span> <span class="o">=</span> <span class="n">fieldnames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span> <span class="o">=</span> <span class="n">location_name</span>
        <span class="n">field_short_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">]</span>
        <span class="n">field_str</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field_short_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">field_str</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">}</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;location_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_points_xy</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_points_z</span> <span class="o">=</span> <span class="n">n_points_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points_z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points_xy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_z_min</span> <span class="o">=</span> <span class="n">z_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_z_max</span> <span class="o">=</span> <span class="n">z_max</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">field_dims</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">field_dims</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">value_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;z_coord&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">f_short</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fieldnames</span><span class="p">,</span> <span class="n">field_short_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_dims</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_short</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_dims</span><span class="p">[</span><span class="n">f</span><span class="p">]):</span>
                    <span class="n">f_comp_name</span> <span class="o">=</span> <span class="n">f_short</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variable_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_comp_name</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">solver_obj</span><span class="p">,</span>
            <span class="n">outputdir</span><span class="o">=</span><span class="n">outputdir</span><span class="p">,</span>
            <span class="n">array_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">value_shape</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
            <span class="n">export_to_hdf5</span><span class="o">=</span><span class="n">export_to_hdf5</span><span class="p">,</span>
            <span class="n">append_to_log</span><span class="o">=</span><span class="n">append_to_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span>
        <span class="k">if</span> <span class="n">outputdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">outputdir</span>

        <span class="c1"># construct mesh points for evaluation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points_z</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points_z</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_update_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">bathymetry_2d</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">))</span>
            <span class="n">elev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">elev_cg_2d</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">PointNotInDomainError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Transect &quot;</span><span class="si">{:}</span><span class="s1">&quot; point out of horizontal domain&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-5</span>  <span class="c1"># nudge points to avoid libspatialindex errors</span>
        <span class="n">z_min</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="n">epsilon</span><span class="p">)</span>
        <span class="n">z_max</span> <span class="o">=</span> <span class="n">elev</span> <span class="o">-</span> <span class="n">epsilon</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_z_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">z_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_z_min</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_z_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">z_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_z_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z_max</span><span class="p">,</span> <span class="n">z_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points_z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">trans_y</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">trans_z</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_coords</span><span class="p">()</span>

        <span class="n">outvals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_z</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_obj</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
            <span class="n">field_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_dims</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">))</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">PointNotInDomainError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">: Cannot evaluate data on transect </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">))</span>
                <span class="k">raise</span> <span class="n">e</span>
            <span class="c1"># arr has shape (nxy, nz, ncomponents)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">field_dim</span><span class="p">]</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># convert to list of components [(nxy, nz) , ...]</span>
            <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
            <span class="n">outvals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outvals</span><span class="p">)</span>

<div class="viewcode-block" id="TransectCallback.message_str"><a class="viewcode-back" href="../../thetis.html#thetis.callback.TransectCallback.message_str">[docs]</a>    <span class="k">def</span> <span class="nf">message_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;Evaluated transect &quot;</span><span class="si">{:}</span><span class="s1">&quot;:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location_name</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_names</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">minval</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">maxval</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">line</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">fieldname</span><span class="si">}</span><span class="s1"> range: </span><span class="si">{</span><span class="n">minval</span><span class="si">:</span><span class="s1">.3g</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">maxval</span><span class="si">:</span><span class="s1">.3g</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2020, Tuomas Karna et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>