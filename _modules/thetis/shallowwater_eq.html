<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>thetis.shallowwater_eq &#8212; Thetis 0+untagged.2082.gf1a0bbb documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/thetis.css?v=0f3339d6" />
    <script src="../../_static/documentation_options.js?v=ccd1159c"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<!-- <link rel="stylesheet" href="../../_static/featured.css"> -->


<link rel="shortcut icon" href="../../_static/icon_thetis.ico" />


  </head><body>
<div class="wrapper">
  <a href="../../index.html"><img src="../../_static/banner.jpg" height="180px" alt="Thetis Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
        <li class="page_item"><a href="../../documentation.html" title="Thetis documentation">Documentation</a></li>
        <li class="page_item"><a href="../../download.html" title="Install Thetis">Download</a></li>
        <li class="page_item"><a href="../../team.html" title="Development team">Team</a></li>
        <li class="page_item"><a href="../../publications.html" title="Publications">Publications</a></li>
        <li class="page_item"><a href="../../funding.html" title="Our financial supporters">Funding</a></li>
        <li class="page_item"><a href="../../contact.html" title="Getting in touch">Contact</a></li>
        <li class="page_item"><a href="https://github.com/thetisproject/thetis" title="Thetis source on GitHub">GitHub</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="_modules/thetis/shallowwater_eq">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for thetis.shallowwater_eq</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Depth averaged shallow water equations</span>

<span class="sd">---------</span>
<span class="sd">Equations</span>
<span class="sd">---------</span>

<span class="sd">The state variables are water elevation, :math:`\eta`, and depth averaged</span>
<span class="sd">velocity :math:`\bar{\textbf{u}}`.</span>

<span class="sd">Denoting the total water depth by :math:`H=\eta + h`, the non-conservative form of</span>
<span class="sd">the free surface equation is</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \eta}{\partial t} + \nabla \cdot (H \bar{\textbf{u}}) = 0</span>
<span class="sd">   :label: swe_freesurf</span>

<span class="sd">The non-conservative momentum equation reads</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \bar{\textbf{u}}}{\partial t} +</span>
<span class="sd">   \bar{\textbf{u}} \cdot \nabla\bar{\textbf{u}} +</span>
<span class="sd">   f\textbf{e}_z\wedge \bar{\textbf{u}} +</span>
<span class="sd">   g \nabla \eta +</span>
<span class="sd">   \nabla \left(\frac{p_a}{\rho_0} \right) +</span>
<span class="sd">   g \frac{1}{H}\int_{-h}^\eta \nabla r dz</span>
<span class="sd">   = \nabla \cdot \big( \nu_h ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T )\big) +</span>
<span class="sd">   \frac{\nu_h \nabla(H)}{H} \cdot ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T ),</span>
<span class="sd">   :label: swe_momentum</span>

<span class="sd">where :math:`g` is the gravitational acceleration, :math:`f` is the Coriolis</span>
<span class="sd">frequency, :math:`\wedge` is the cross product, :math:`\textbf{e}_z` is a vertical unit vector,</span>
<span class="sd">:math:`p_a` is the atmospheric pressure at the free surface, and :math:`\nu_h`</span>
<span class="sd">is viscosity. Water density is given by :math:`\rho = \rho&#39;(T, S, p) + \rho_0`,</span>
<span class="sd">where :math:`\rho_0` is a constant reference density.</span>

<span class="sd">Above :math:`r` denotes the baroclinic head</span>

<span class="sd">.. math::</span>

<span class="sd">  r = \frac{1}{\rho_0} \int_{z}^\eta  \rho&#39; d\zeta.</span>

<span class="sd">In the case of purely barotropic problems the :math:`r` and the internal pressure</span>
<span class="sd">gradient are omitted.</span>

<span class="sd">If the option :attr:`.ModelOptions.use_nonlinear_equations` is ``False``, we solve the linear shallow water</span>
<span class="sd">equations (i.e. wave equation):</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \eta}{\partial t} + \nabla \cdot (h \bar{\textbf{u}}) = 0</span>
<span class="sd">   :label: swe_freesurf_linear</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \bar{\textbf{u}}}{\partial t} +</span>
<span class="sd">   f\textbf{e}_z\wedge \bar{\textbf{u}} +</span>
<span class="sd">   g \nabla \eta</span>
<span class="sd">   = \nabla \cdot \big( \nu_h ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T )\big) +</span>
<span class="sd">   \frac{\nu_h \nabla(H)}{H} \cdot ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T ).</span>
<span class="sd">   :label: swe_momentum_linear</span>

<span class="sd">In case of a 3D problem with mode splitting, we use a simplified 2D</span>
<span class="sd">system that contains nothing but the rotational external gravity waves:</span>

<span class="sd">.. math::</span>
<span class="sd">    \frac{\partial \eta}{\partial t} + \nabla \cdot (H \bar{\textbf{u}}) = 0</span>
<span class="sd">    :label: swe_freesurf_modesplit</span>

<span class="sd">.. math::</span>
<span class="sd">    \frac{\partial \bar{\textbf{u}}}{\partial t} +</span>
<span class="sd">    f\textbf{e}_z\wedge \bar{\textbf{u}} +</span>
<span class="sd">    g \nabla \eta</span>
<span class="sd">    = \textbf{G},</span>
<span class="sd">    :label: swe_momentum_modesplit</span>

<span class="sd">where :math:`\textbf{G}` is a source term used to couple the 2D and 3D momentum</span>
<span class="sd">equations.</span>

<span class="sd">-------------------</span>
<span class="sd">Boundary Conditions</span>
<span class="sd">-------------------</span>

<span class="sd">All boundary conditions are imposed weakly by providing external values for</span>
<span class="sd">:math:`\eta` and :math:`\bar{\textbf{u}}`.</span>

<span class="sd">Boundary conditions are set with a dictionary that defines all prescribed</span>
<span class="sd">variables at each open boundary.</span>
<span class="sd">For example, to assign elevation and volume flux on boundary ``1`` we set</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    swe_bnd_funcs = {}</span>
<span class="sd">    swe_bnd_funcs[1] = {&#39;elev&#39;:myfunc1, &#39;flux&#39;:myfunc2}</span>

<span class="sd">where ``myfunc1`` and ``myfunc2`` are :class:`Constant` or :class:`Function`</span>
<span class="sd">objects.</span>

<span class="sd">The user can provide :math:`\eta` and/or :math:`\bar{\textbf{u}}` values.</span>
<span class="sd">Supported combinations are:</span>

<span class="sd">- *unspecified* : impermeable (land) boundary, implies symmetric :math:`\eta` condition and zero normal velocity</span>
<span class="sd">- ``&#39;elev&#39;``: elevation only, symmetric velocity (usually unstable)</span>
<span class="sd">- ``&#39;uv&#39;``: 2d velocity vector :math:`\bar{\textbf{u}}=(u, v)` (in mesh coordinates), symmetric elevation</span>
<span class="sd">- ``&#39;un&#39;``: normal velocity (scalar, positive out of domain), symmetric elevation</span>
<span class="sd">- ``&#39;flux&#39;``: normal volume flux (scalar, positive out of domain), symmetric elevation</span>
<span class="sd">- ``&#39;elev&#39;`` and ``&#39;uv&#39;``: water elevation and 2d velocity vector</span>
<span class="sd">- ``&#39;elev&#39;`` and ``&#39;un&#39;``: water elevation and normal velocity</span>
<span class="sd">- ``&#39;elev&#39;`` and ``&#39;flux&#39;``: water elevation and normal flux</span>

<span class="sd">The boundary conditions are assigned to the :class:`.FlowSolver2d` or</span>
<span class="sd">:class:`.FlowSolver` objects:</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    solver_obj = solver2d.FlowSolver2d(...)</span>
<span class="sd">    ...</span>
<span class="sd">    solver_obj.bnd_functions[&#39;shallow_water&#39;] = swe_bnd_funcs</span>

<span class="sd">Internally the boundary conditions passed to the :meth:`.Term.residual` method</span>
<span class="sd">of each term:</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    adv_term = shallowwater_eq.HorizontalAdvectionTerm(...)</span>
<span class="sd">    adv_form = adv_term.residual(..., bnd_conditions=swe_bnd_funcs)</span>

<span class="sd">------------------</span>
<span class="sd">Wetting and drying</span>
<span class="sd">------------------</span>

<span class="sd">If the option :attr:`.ModelOptions.use_wetting_and_drying` is ``True``, then wetting and</span>
<span class="sd">drying is included through the formulation of Karna et al. (2011).</span>

<span class="sd">The method introduces a modified bathymetry :math:`\tilde{h} = h + f(H)`, which ensures</span>
<span class="sd">positive total water depth, with :math:`f(H)` defined by</span>

<span class="sd">.. math::</span>
<span class="sd">   f(H) = \frac{1}{2}(\sqrt{H^2 + \alpha^2} - H),</span>

<span class="sd">introducing a wetting-drying parameter :math:`\alpha`, with dimensions of length. This</span>
<span class="sd">results in a modified total water depth :math:`\tilde{H}=H+f(H)`.</span>

<span class="sd">The value for :math:`\alpha` is specified by the user through the</span>
<span class="sd">option :attr:`.ModelOptions.wetting_and_drying_alpha`, in units of meters. The default value</span>
<span class="sd">for :attr:`.ModelOptions.wetting_and_drying_alpha` is 0.5, but the appropriate value is problem</span>
<span class="sd">specific and should be set by the user.</span>

<span class="sd">An approximate method for selecting a suitable value for :math:`\alpha` is suggested</span>
<span class="sd">by Karna et al. (2011). Defining :math:`L_x` as the horizontal length scale of the</span>
<span class="sd">mesh elements at the wet-dry front, it can be reasoned that :math:`\alpha \approx |L_x</span>
<span class="sd">\nabla h|` yields a suitable choice. Smaller :math:`\alpha` leads to a more accurate</span>
<span class="sd">solution to the shallow water equations in wet regions, but if :math:`\alpha` is too</span>
<span class="sd">small the simulation will become unstable.</span>

<span class="sd">When wetting and drying is turned on, two things occur:</span>

<span class="sd">    1. All instances of the height, :math:`H`, are replaced by :math:`\tilde{H}` (as defined above);</span>
<span class="sd">    2. An additional displacement term :math:`\frac{\partial \tilde{h}}{\partial t}` is added to the bathymetry in the free surface equation.</span>

<span class="sd">The free surface and momentum equations then become:</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \eta}{\partial t} + \frac{\partial \tilde{h}}{\partial t} + \nabla \cdot (\tilde{H} \bar{\textbf{u}}) = 0,</span>
<span class="sd">   :label: swe_freesurf_wd</span>

<span class="sd">.. math::</span>
<span class="sd">   \frac{\partial \bar{\textbf{u}}}{\partial t} +</span>
<span class="sd">   \bar{\textbf{u}} \cdot \nabla\bar{\textbf{u}} +</span>
<span class="sd">   f\textbf{e}_z\wedge \bar{\textbf{u}} +</span>
<span class="sd">   g \nabla \eta +</span>
<span class="sd">   g \frac{1}{\tilde{H}}\int_{-h}^\eta \nabla r dz</span>
<span class="sd">   = \nabla \cdot \big( \nu_h ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T )\big) +</span>
<span class="sd">   \frac{\nu_h \nabla(\tilde{H})}{\tilde{H}} \cdot ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T ).</span>
<span class="sd">   :label: swe_momentum_wd</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utility</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.equation</span><span class="w"> </span><span class="kn">import</span> <span class="n">Term</span><span class="p">,</span> <span class="n">Equation</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;BaseShallowWaterEquation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterEquations&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ModeSplit2DEquations&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterMomentumEquation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FreeSurfaceEquation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterMomentumTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ShallowWaterContinuityTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;HUDivTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ContinuitySourceTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;HorizontalAdvectionTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;HorizontalViscosityTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ExternalPressureGradientTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;CoriolisTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LinearDragTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;QuadraticDragTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;BottomDrag3DTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;MomentumSourceTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;WindStressTerm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;AtmosphericPressureTerm&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">g_grav</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;g_grav&#39;</span><span class="p">]</span>
<span class="n">rho_0</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;rho0&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="ShallowWaterTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ShallowWaterTerm</span><span class="p">(</span><span class="n">Term</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic term in the shallow water equations that provides commonly used</span>
<span class="sd">    members and mapping for boundary functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span>
                 <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterTerm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

        <span class="c1"># mesh dependent variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellsize</span> <span class="o">=</span> <span class="n">CellSize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">cell_dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_the_sphere</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">geometric_dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span>

        <span class="c1"># define measures with a reasonable quadrature degree</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">,</span>
                     <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">ufl_domain</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dS</span> <span class="o">=</span> <span class="n">dS</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">,</span>
                     <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">ufl_domain</span><span class="p">())</span>

<div class="viewcode-block" id="ShallowWaterTerm.get_bnd_functions">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterTerm.get_bnd_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_bnd_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta_in</span><span class="p">,</span> <span class="n">uv_in</span><span class="p">,</span> <span class="n">bnd_id</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns external values of elev and uv for all supported</span>
<span class="sd">        boundary conditions.</span>

<span class="sd">        Volume flux (flux) and normal velocity (un) are defined positive out of</span>
<span class="sd">        the domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bnd_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_len</span><span class="p">[</span><span class="n">bnd_id</span><span class="p">]</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="p">[</span><span class="n">bnd_id</span><span class="p">]</span>
        <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;elev&#39;</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="ow">and</span> <span class="s1">&#39;uv&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;elev&#39;</span><span class="p">]</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s1">&#39;elev&#39;</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="ow">and</span> <span class="s1">&#39;un&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;elev&#39;</span><span class="p">]</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;un&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">elif</span> <span class="s1">&#39;elev&#39;</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="ow">and</span> <span class="s1">&#39;flux&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;elev&#39;</span><span class="p">]</span>
            <span class="n">h_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_ext</span><span class="p">)</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">h_ext</span><span class="o">*</span><span class="n">bnd_len</span>  <span class="c1"># NOTE using external data only</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">area</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">elif</span> <span class="s1">&#39;elev&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;elev&#39;</span><span class="p">]</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">uv_in</span>  <span class="c1"># assume symmetry</span>
        <span class="k">elif</span> <span class="s1">&#39;uv&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">eta_in</span>  <span class="c1"># assume symmetry</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s1">&#39;un&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">eta_in</span>  <span class="c1"># assume symmetry</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;un&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">elif</span> <span class="s1">&#39;flux&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">eta_ext</span> <span class="o">=</span> <span class="n">eta_in</span>  <span class="c1"># assume symmetry</span>
            <span class="n">h_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_ext</span><span class="p">)</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">h_ext</span><span class="o">*</span><span class="n">bnd_len</span>  <span class="c1"># NOTE using internal elevation</span>
            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">area</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">if</span> <span class="n">eta_ext</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">uv_ext</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unsupported bnd type, one of &quot;elev&quot;, &quot;uv&quot;, &quot;un&quot;, &#39;</span>
                            <span class="s1">&#39;or &quot;flux&quot; must be defined on boundary &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">bnd_marker</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">funcs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span></div>


<div class="viewcode-block" id="ShallowWaterTerm.impose_dynamic_bnd">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterTerm.impose_dynamic_bnd">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">impose_dynamic_bnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnd_funcs</span><span class="p">,</span> <span class="n">bnd_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the prognostic variables have been specified on the boundary.</span>

<span class="sd">        If any prognostic value has been specified, dynamic boundary terms</span>
<span class="sd">        will be evaluated. If not, a closed boundary is assumed (which implies</span>
<span class="sd">        e.g. that volume flux boundary terms are omitted).</span>

<span class="sd">        :arg bnd_funcs: None or dictionary of boundary coefficients.</span>
<span class="sd">        :arg bnd_id: Boundary marker id</span>
<span class="sd">        :returns: True if elev or uv is defined, otherwise False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">open_tags</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;elev&#39;</span><span class="p">,</span> <span class="s1">&#39;uv&#39;</span><span class="p">,</span> <span class="s1">&#39;un&#39;</span><span class="p">,</span> <span class="s1">&#39;flux&#39;</span><span class="p">]</span>
        <span class="n">all_tags</span> <span class="o">=</span> <span class="n">open_tags</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;drag&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bnd_funcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">bnd_funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_tags</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid boundary tag &quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;specified on boundary </span><span class="si">{</span><span class="n">bnd_id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">open_tags</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>
</div>



<div class="viewcode-block" id="ShallowWaterMomentumTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterMomentumTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ShallowWaterMomentumTerm</span><span class="p">(</span><span class="n">ShallowWaterTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic term in the shallow water momentum equation that provides commonly used</span>
<span class="sd">    members and mapping for boundary functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span>
                 <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">u_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span> <span class="o">=</span> <span class="n">u_test</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_space</span> <span class="o">=</span> <span class="n">u_space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta_space</span> <span class="o">=</span> <span class="n">eta_space</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u_continuity</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span><span class="o">.</span><span class="n">horizontal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta_is_dg</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span><span class="o">.</span><span class="n">horizontal</span> <span class="o">==</span> <span class="s1">&#39;dg&#39;</span></div>



<div class="viewcode-block" id="ShallowWaterContinuityTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterContinuityTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ShallowWaterContinuityTerm</span><span class="p">(</span><span class="n">ShallowWaterTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic term in the depth-integrated continuity equation that provides commonly used</span>
<span class="sd">    members and mapping for boundary functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span>
                 <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterContinuityTerm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">eta_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span> <span class="o">=</span> <span class="n">eta_test</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta_space</span> <span class="o">=</span> <span class="n">eta_space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_space</span> <span class="o">=</span> <span class="n">u_space</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u_continuity</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span><span class="o">.</span><span class="n">horizontal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta_is_dg</span> <span class="o">=</span> <span class="n">element_continuity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span><span class="o">.</span><span class="n">horizontal</span> <span class="o">==</span> <span class="s1">&#39;dg&#39;</span></div>



<div class="viewcode-block" id="ExternalPressureGradientTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ExternalPressureGradientTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExternalPressureGradientTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    External pressure gradient term, :math:`g \nabla \eta`</span>

<span class="sd">    The weak form reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega g \nabla \eta \cdot \boldsymbol{\psi} dx</span>
<span class="sd">        = \int_\Gamma g \eta^* \text{jump}(\boldsymbol{\psi} \cdot \textbf{n}) dS</span>
<span class="sd">        - \int_\Omega g \eta \nabla \cdot \boldsymbol{\psi} dx</span>

<span class="sd">    where the right hand side has been integrated by parts; :math:`\textbf{n}`</span>
<span class="sd">    denotes the unit normal of the element interfaces, :math:`n^*` is value at</span>
<span class="sd">    the interface obtained from an approximate Riemann solver.</span>

<span class="sd">    If :math:`\eta` belongs to a discontinuous function space, the form on the</span>
<span class="sd">    right hand side is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ExternalPressureGradientTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ExternalPressureGradientTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>

        <span class="n">head</span> <span class="o">=</span> <span class="n">eta</span>

        <span class="n">grad_eta_by_parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_is_dg</span>

        <span class="k">if</span> <span class="n">grad_eta_by_parts</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">g_grav</span><span class="o">*</span><span class="n">head</span><span class="o">*</span><span class="n">nabla_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">if</span> <span class="n">uv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">head_star</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">avg</span><span class="p">(</span><span class="n">total_h</span><span class="p">)</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head_star</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">head_star</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impose_dynamic_bnd</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">):</span>
                    <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="c1"># Compute linear riemann solution with eta, eta_ext, uv, uv_ext</span>
                    <span class="n">un_jump</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv</span> <span class="o">-</span> <span class="n">uv_ext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                    <span class="n">eta_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">eta_ext</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">total_h</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">un_jump</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">eta_rie</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># assume land boundary</span>
                    <span class="c1"># impermeability implies external un=0</span>
                    <span class="n">un_jump</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                    <span class="n">head_rie</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">total_h</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">un_jump</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">head_rie</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">g_grav</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">head</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impose_dynamic_bnd</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">):</span>
                    <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="c1"># Compute linear riemann solution with eta, eta_ext, uv, uv_ext</span>
                    <span class="n">un_jump</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv</span> <span class="o">-</span> <span class="n">uv_ext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                    <span class="n">eta_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">eta_ext</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">total_h</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">un_jump</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">g_grav</span><span class="o">*</span><span class="p">(</span><span class="n">eta_rie</span><span class="o">-</span><span class="n">head</span><span class="p">)</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div>
</div>



<div class="viewcode-block" id="HUDivTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HUDivTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HUDivTerm</span><span class="p">(</span><span class="n">ShallowWaterContinuityTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Divergence term, :math:`\nabla \cdot (H \bar{\textbf{u}})`</span>

<span class="sd">    The weak form reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega \nabla \cdot (H \bar{\textbf{u}}) \phi dx</span>
<span class="sd">        = \int_\Gamma (H^* \bar{\textbf{u}}^*) \cdot \text{jump}(\phi \textbf{n}) dS</span>
<span class="sd">        - \int_\Omega H (\bar{\textbf{u}}\cdot\nabla \phi) dx</span>

<span class="sd">    where the right hand side has been integrated by parts; :math:`\textbf{n}`</span>
<span class="sd">    denotes the unit normal of the element interfaces, and :math:`\text{jump}`</span>
<span class="sd">    and :math:`\text{avg}` denote the jump and average operators across the</span>
<span class="sd">    interface. :math:`H^*, \bar{\textbf{u}}^*` are values at the interface</span>
<span class="sd">    obtained from an approximate Riemann solver.</span>

<span class="sd">    If :math:`\bar{\textbf{u}}` belongs to a discontinuous function space,</span>
<span class="sd">    the form on the right hand side is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="HUDivTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HUDivTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>

        <span class="n">hu_by_parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_continuity</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dg&#39;</span><span class="p">,</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">hu_by_parts</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="p">),</span> <span class="n">total_h</span><span class="o">*</span><span class="n">uv</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_is_dg</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">total_h</span><span class="p">)</span>
                <span class="n">uv_rie</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">g_grav</span><span class="o">/</span><span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">jump</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                <span class="n">hu_star</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">uv_rie</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="n">inner</span><span class="p">(</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">),</span> <span class="n">hu_star</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impose_dynamic_bnd</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">):</span>
                    <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="n">eta_ext_old</span><span class="p">,</span> <span class="n">uv_ext_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta_old</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="c1"># Compute linear riemann solution with eta, eta_ext, uv, uv_ext</span>
                    <span class="n">total_h_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_ext_old</span><span class="p">)</span>
                    <span class="n">h_av</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">total_h</span> <span class="o">+</span> <span class="n">total_h_ext</span><span class="p">)</span>
                    <span class="n">eta_jump</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">-</span> <span class="n">eta_ext</span>
                    <span class="n">un_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">uv</span> <span class="o">+</span> <span class="n">uv_ext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">g_grav</span><span class="o">/</span><span class="n">h_av</span><span class="p">)</span><span class="o">*</span><span class="n">eta_jump</span>
                    <span class="n">un_jump</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv_old</span> <span class="o">-</span> <span class="n">uv_ext_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                    <span class="n">eta_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">eta_old</span> <span class="o">+</span> <span class="n">eta_ext_old</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">h_av</span><span class="o">/</span><span class="n">g_grav</span><span class="p">)</span><span class="o">*</span><span class="n">un_jump</span>
                    <span class="n">h_rie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_rie</span><span class="p">)</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">h_rie</span><span class="o">*</span><span class="n">un_rie</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">total_h</span><span class="o">*</span><span class="n">uv</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">impose_dynamic_bnd</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;un&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">total_h</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div>
</div>



<div class="viewcode-block" id="HorizontalAdvectionTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HorizontalAdvectionTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HorizontalAdvectionTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Advection of momentum term, :math:`\bar{\textbf{u}} \cdot \nabla\bar{\textbf{u}}`</span>

<span class="sd">    The weak form is</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega \bar{\textbf{u}} \cdot \nabla\bar{\textbf{u}} \cdot \boldsymbol{\psi} dx</span>
<span class="sd">        = - \int_\Omega \nabla_h \cdot (\bar{\textbf{u}} \boldsymbol{\psi}) \cdot \bar{\textbf{u}} dx</span>
<span class="sd">        + \int_\Gamma \text{avg}(\bar{\textbf{u}}) \cdot \text{jump}(\boldsymbol{\psi}</span>
<span class="sd">        (\bar{\textbf{u}}\cdot\textbf{n})) dS</span>

<span class="sd">    where the right hand side has been integrated by parts;</span>
<span class="sd">    :math:`\textbf{n}` is the unit normal of</span>
<span class="sd">    the element interfaces, and :math:`\text{jump}` and :math:`\text{avg}` denote the</span>
<span class="sd">    jump and average operators across the interface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="HorizontalAdvectionTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HorizontalAdvectionTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_nonlinear_equations</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">horiz_advection_by_parts</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">horiz_advection_by_parts</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">div</span><span class="p">(</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">)),</span> <span class="n">uv</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_continuity</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dg&#39;</span><span class="p">,</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">]:</span>
                <span class="n">un_av</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">avg</span><span class="p">(</span><span class="n">uv_old</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span>
                <span class="c1"># NOTE mean flux</span>
                <span class="n">uv_avg</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="n">inner</span><span class="p">(</span><span class="n">uv_avg</span><span class="p">,</span> <span class="n">jump</span><span class="p">(</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
                <span class="c1"># Lax-Friedrichs stabilization</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_lax_friedrichs_velocity</span><span class="p">:</span>
                    <span class="n">uv_lax_friedrichs</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lax_friedrichs_velocity_scaling_factor&#39;</span><span class="p">)</span>
                    <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">un_av</span><span class="p">)</span><span class="o">*</span><span class="n">uv_lax_friedrichs</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">),</span> <span class="n">jump</span><span class="p">(</span><span class="n">uv</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
                    <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                        <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                        <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">impose_dynamic_bnd</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">):</span>
                            <span class="c1"># impose impermeability with mirror velocity</span>
                            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
                            <span class="n">uv_ext</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">n</span>
                            <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">uv_old</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">uv_lax_friedrichs</span>
                            <span class="n">f</span> <span class="o">+=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">uv</span><span class="o">-</span><span class="n">uv_ext</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impose_dynamic_bnd</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">):</span>
                    <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="n">eta_ext_old</span><span class="p">,</span> <span class="n">uv_ext_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta_old</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                    <span class="c1"># Compute linear riemann solution with eta, eta_ext, uv, uv_ext</span>
                    <span class="n">eta_jump</span> <span class="o">=</span> <span class="n">eta_old</span> <span class="o">-</span> <span class="n">eta_ext_old</span>
                    <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>
                    <span class="n">un_rie</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">uv_old</span> <span class="o">+</span> <span class="n">uv_ext_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">g_grav</span><span class="o">/</span><span class="n">total_h</span><span class="p">)</span><span class="o">*</span><span class="n">eta_jump</span>
                    <span class="n">uv_av</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">uv_ext</span> <span class="o">+</span> <span class="n">uv</span><span class="p">)</span>
                    <span class="n">f</span> <span class="o">+=</span> <span class="n">un_rie</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">uv_av</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div>
</div>



<div class="viewcode-block" id="HorizontalViscosityTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HorizontalViscosityTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HorizontalViscosityTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Viscosity of momentum term</span>

<span class="sd">    If option :attr:`.ModelOptions.use_grad_div_viscosity_term` is ``True``, we</span>
<span class="sd">    use the symmetric viscous stress :math:`\boldsymbol{\tau}_\nu = \nu_h ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T )`.</span>
<span class="sd">    Using the symmetric interior penalty method the weak form then reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega -\nabla \cdot \boldsymbol{\tau}_\nu \cdot \boldsymbol{\psi} dx</span>
<span class="sd">        =&amp; \int_\Omega (\nabla \boldsymbol{\psi}) : \boldsymbol{\tau}_\nu dx \\</span>
<span class="sd">        &amp;- \int_\Gamma \text{jump}(\boldsymbol{\psi} \textbf{n}) \cdot \text{avg}(\boldsymbol{\tau}_\nu) dS</span>
<span class="sd">        - \int_\Gamma \text{avg}(\nu_h)\big(\text{jump}(\bar{\textbf{u}} \textbf{n}) + \text{jump}(\bar{\textbf{u}} \textbf{n})^T\big) \cdot \text{avg}(\nabla \boldsymbol{\psi}) dS \\</span>
<span class="sd">        &amp;+ \int_\Gamma \sigma \text{avg}(\nu_h) \big(\text{jump}(\bar{\textbf{u}} \textbf{n}) + \text{jump}(\bar{\textbf{u}} \textbf{n})^T\big) \cdot \text{jump}(\boldsymbol{\psi} \textbf{n}) dS</span>

<span class="sd">    where :math:`\sigma` is a penalty parameter, see Hillewaert (2013).</span>

<span class="sd">    If option :attr:`.ModelOptions.use_grad_div_viscosity_term` is ``False``,</span>
<span class="sd">    we use viscous stress :math:`\boldsymbol{\tau}_\nu = \nu_h \nabla \bar{\textbf{u}}`.</span>
<span class="sd">    In this case the weak form is</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega -\nabla \cdot \boldsymbol{\tau}_\nu \cdot \boldsymbol{\psi} dx</span>
<span class="sd">        =&amp; \int_\Omega (\nabla \boldsymbol{\psi}) : \boldsymbol{\tau}_\nu dx \\</span>
<span class="sd">        &amp;- \int_\Gamma \text{jump}(\boldsymbol{\psi} \textbf{n}) \cdot \text{avg}(\boldsymbol{\tau}_\nu) dS</span>
<span class="sd">        - \int_\Gamma \text{avg}(\nu_h)\text{jump}(\bar{\textbf{u}} \textbf{n}) \cdot \text{avg}(\nabla \boldsymbol{\psi}) dS \\</span>
<span class="sd">        &amp;+ \int_\Gamma \sigma \text{avg}(\nu_h) \text{jump}(\bar{\textbf{u}} \textbf{n}) \cdot \text{jump}(\boldsymbol{\psi} \textbf{n}) dS</span>

<span class="sd">    If option :attr:`.ModelOptions.use_grad_depth_viscosity_term` is ``True``, we also include</span>
<span class="sd">    the term</span>

<span class="sd">    .. math::</span>
<span class="sd">        \boldsymbol{\tau}_{\nabla H} = - \frac{\nu_h \nabla(H)}{H} \cdot ( \nabla \bar{\textbf{u}} + (\nabla \bar{\textbf{u}})^T )</span>

<span class="sd">    as a source term.</span>

<span class="sd">    Hillewaert, Koen (2013). Development of the discontinuous Galerkin method</span>
<span class="sd">    for high-resolution, large scale CFD and acoustics in industrial</span>
<span class="sd">    geometries. PhD Thesis. Université catholique de Louvain.</span>
<span class="sd">    https://dial.uclouvain.be/pr/boreal/object/boreal:128254/</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="HorizontalViscosityTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.HorizontalViscosityTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>

        <span class="n">nu</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;viscosity_h&#39;</span><span class="p">)</span>
        <span class="n">sipg_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">sipg_factor</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_grad_div_viscosity_term</span><span class="p">:</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">sym</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">uv</span><span class="p">))</span>
            <span class="n">stress_jump</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">sym</span><span class="p">(</span><span class="n">tensor_jump</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
            <span class="n">stress_jump</span> <span class="o">=</span> <span class="n">avg</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span><span class="o">*</span><span class="n">tensor_jump</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">),</span> <span class="n">stress</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_continuity</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dg&#39;</span><span class="p">,</span> <span class="s1">&#39;hdiv&#39;</span><span class="p">]:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">()</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="n">triangle</span> <span class="k">else</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">l_normal</span> <span class="o">=</span> <span class="n">CellVolume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span> <span class="o">/</span> <span class="n">FacetArea</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
            <span class="c1"># by default the factor is multiplied by 2 to ensure convergence</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">sipg_factor</span> <span class="o">*</span> <span class="n">cp</span> <span class="o">/</span> <span class="n">l_normal</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
            <span class="n">sm</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
            <span class="n">sigma_max</span> <span class="o">=</span> <span class="n">conditional</span><span class="p">(</span><span class="n">sp</span> <span class="o">&gt;</span> <span class="n">sm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sm</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="o">+</span> <span class="n">sigma_max</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">tensor_jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">stress_jump</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
                <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">avg</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)),</span> <span class="n">stress_jump</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
                <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">tensor_jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">avg</span><span class="p">(</span><span class="n">stress</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dS</span>
            <span class="p">)</span>

            <span class="c1"># Dirichlet bcs only for DG</span>
            <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
                <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impose_dynamic_bnd</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">):</span>
                    <span class="k">if</span> <span class="s1">&#39;un&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                        <span class="n">delta_uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;un&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">n</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">eta_ext</span><span class="p">,</span> <span class="n">uv_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bnd_functions</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">bnd_marker</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">uv_ext</span> <span class="ow">is</span> <span class="n">uv</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">delta_uv</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">-</span> <span class="n">uv_ext</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_grad_div_viscosity_term</span><span class="p">:</span>
                        <span class="n">stress_jump</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">sym</span><span class="p">(</span><span class="n">outer</span><span class="p">(</span><span class="n">delta_uv</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stress_jump</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="n">outer</span><span class="p">(</span><span class="n">delta_uv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

                    <span class="n">f</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">sigma</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">stress_jump</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                        <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">),</span> <span class="n">stress_jump</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                        <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">stress</span><span class="p">)</span><span class="o">*</span><span class="n">ds_bnd</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_grad_depth_viscosity_term</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">total_h</span><span class="p">)</span><span class="o">/</span><span class="n">total_h</span><span class="p">,</span> <span class="n">stress</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div>
</div>



<div class="viewcode-block" id="CoriolisTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.CoriolisTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CoriolisTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coriolis term, :math:`f\textbf{e}_z\wedge \bar{\textbf{u}}`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CoriolisTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.CoriolisTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">coriolis</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coriolis&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">coriolis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_the_sphere</span><span class="p">:</span>
                <span class="n">outward_normals</span> <span class="o">=</span> <span class="n">CellNormal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">outward_normals</span><span class="p">,</span> <span class="n">uv</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">coriolis</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ez_x_uv</span> <span class="o">=</span> <span class="o">-</span><span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="n">coriolis</span><span class="o">*</span><span class="n">ez_x_uv</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div>
</div>



<div class="viewcode-block" id="WindStressTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.WindStressTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WindStressTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wind stress term, :math:`-\tau_w/(H \rho_0)`</span>

<span class="sd">    Here :math:`\tau_w` is a user-defined wind stress :class:`Function`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WindStressTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.WindStressTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">wind_stress</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;wind_stress&#39;</span><span class="p">)</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">wind_stress</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">wind_stress</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">/</span><span class="n">total_h</span><span class="o">/</span><span class="n">rho_0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="n">f</span></div>
</div>



<div class="viewcode-block" id="AtmosphericPressureTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.AtmosphericPressureTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AtmosphericPressureTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Atmospheric pressure term, :math:`\nabla (p_a / \rho_0)`</span>

<span class="sd">    Here :math:`p_a` is a user-defined atmospheric pressure :class:`Function`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="AtmosphericPressureTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.AtmosphericPressureTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">atmospheric_pressure</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;atmospheric_pressure&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">atmospheric_pressure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">atmospheric_pressure</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">/</span><span class="n">rho_0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div>
</div>



<div class="viewcode-block" id="QuadraticDragTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.QuadraticDragTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">QuadraticDragTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quadratic Manning bottom friction term</span>
<span class="sd">    :math:`C_D \| \bar{\textbf{u}} \| \bar{\textbf{u}}`</span>

<span class="sd">    where the drag coefficient is computed with the Manning formula</span>

<span class="sd">    .. math::</span>
<span class="sd">        C_D = g \frac{\mu^2}{H^{1/3}}</span>

<span class="sd">    if the Manning coefficient :math:`\mu` is defined (see field :attr:`manning_drag_coefficient`).</span>
<span class="sd">    Otherwise :math:`C_D` is taken as a constant (see field :attr:`quadratic_drag_coefficient`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="QuadraticDragTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.QuadraticDragTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>
        <span class="n">manning_drag_coefficient</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manning_drag_coefficient&#39;</span><span class="p">)</span>
        <span class="n">nikuradse_bed_roughness</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nikuradse_bed_roughness&#39;</span><span class="p">)</span>
        <span class="n">C_D</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;quadratic_drag_coefficient&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">manning_drag_coefficient</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">C_D</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Cannot set both dimensionless and Manning drag parameter&#39;</span><span class="p">)</span>
            <span class="n">C_D</span> <span class="o">=</span> <span class="n">g_grav</span> <span class="o">*</span> <span class="n">manning_drag_coefficient</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">total_h</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nikuradse_bed_roughness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">manning_drag_coefficient</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Cannot set both Nikuradse drag and Manning drag parameter&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">C_D</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Cannot set both dimensionless and Nikuradse drag parameter&#39;</span><span class="p">)</span>

            <span class="n">kappa</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;von_karman&#39;</span><span class="p">]</span>
            <span class="n">C_D</span> <span class="o">=</span> <span class="n">conditional</span><span class="p">(</span><span class="n">total_h</span> <span class="o">&gt;</span> <span class="n">nikuradse_bed_roughness</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">kappa</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ln</span><span class="p">(</span><span class="mf">11.036</span><span class="o">*</span><span class="n">total_h</span><span class="o">/</span><span class="n">nikuradse_bed_roughness</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">C_D</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">C_D</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">uv_old</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">norm_smoother</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">uv</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_h</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">BoundaryDragTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quadratic friction term on the boundary</span>
<span class="sd">    :math:`C_D \| \bar{\textbf{u}}_t \| \bar{\textbf{u}}_t`</span>

<span class="sd">    where :math:`\bar{\textbf{u}}_t` denotes the tangential velocity component</span>
<span class="sd">    and the drag coefficient :math:`C_D` is user-defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bnd_marker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_markers</span><span class="p">:</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">bnd_conditions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">)</span>
            <span class="n">ds_bnd</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd_marker</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_degree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;drag&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                <span class="n">C_D</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;drag&#39;</span><span class="p">]</span>
                <span class="c1"># compute tangential velocity</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
                <span class="n">ut</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
                <span class="n">ut_old</span> <span class="o">=</span> <span class="n">uv_old</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">uv_old</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
                <span class="n">ut_mag</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">ut_old</span><span class="p">,</span> <span class="n">ut_old</span><span class="p">))</span>
                <span class="n">f</span> <span class="o">+=</span> <span class="n">C_D</span> <span class="o">*</span> <span class="n">ut_mag</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">ut</span><span class="p">)</span> <span class="o">*</span> <span class="n">ds_bnd</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span>


<div class="viewcode-block" id="LinearDragTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.LinearDragTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LinearDragTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear friction term, :math:`C \bar{\textbf{u}}`</span>

<span class="sd">    Here :math:`C` is a user-defined drag coefficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LinearDragTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.LinearDragTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">linear_drag_coefficient</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;linear_drag_coefficient&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">linear_drag_coefficient</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bottom_fri</span> <span class="o">=</span> <span class="n">linear_drag_coefficient</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">uv</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">bottom_fri</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div>
</div>



<div class="viewcode-block" id="BottomDrag3DTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BottomDrag3DTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BottomDrag3DTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bottom drag term consistent with the 3D mode,</span>
<span class="sd">    :math:`C_D \| \textbf{u}_b \| \textbf{u}_b`</span>

<span class="sd">    Here :math:`\textbf{u}_b` is the bottom velocity used in the 3D mode, and</span>
<span class="sd">    :math:`C_D` the corresponding bottom drag.</span>
<span class="sd">    These fields are computed in the 3D model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BottomDrag3DTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BottomDrag3DTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>
        <span class="n">bottom_drag</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bottom_drag&#39;</span><span class="p">)</span>
        <span class="n">uv_bottom</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;uv_bottom&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">bottom_drag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">uv_bottom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">uvb_mag</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">uv_bottom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uv_bottom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">bottom_drag</span><span class="o">*</span><span class="n">uvb_mag</span><span class="o">*</span><span class="n">uv_bottom</span><span class="o">/</span><span class="n">total_h</span>
            <span class="n">bot_friction</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">stress</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">bot_friction</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">TurbineDragTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turbine drag parameterisation implemented through quadratic drag term</span>
<span class="sd">    :math:`c_t \| \bar{\textbf{u}} \| \bar{\textbf{u}}`</span>

<span class="sd">    where the turbine drag :math:`c_t` is related to the turbine thrust coefficient</span>
<span class="sd">    :math:`C_T`, the turbine diameter :math:`A_T`, and the turbine density :math:`d`</span>
<span class="sd">    (n/o turbines per unit area), by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        c_t = (C_T A_T d)/2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span>
                 <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tidal_farms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tidal_farms</span> <span class="o">=</span> <span class="n">tidal_farms</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">total_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">get_total_depth</span><span class="p">(</span><span class="n">eta_old</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">farm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tidal_farms</span><span class="p">:</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">farm</span><span class="o">.</span><span class="n">turbine_density</span>
            <span class="n">c_t</span> <span class="o">=</span> <span class="n">farm</span><span class="o">.</span><span class="n">friction_coefficient</span><span class="p">(</span><span class="n">uv_old</span><span class="p">,</span> <span class="n">total_h</span><span class="p">)</span>
            <span class="n">unorm</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">uv_old</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">))</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">c_t</span> <span class="o">*</span> <span class="n">density</span> <span class="o">*</span> <span class="n">unorm</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">,</span> <span class="n">uv</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_h</span> <span class="o">*</span> <span class="n">farm</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span>


<div class="viewcode-block" id="MomentumSourceTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.MomentumSourceTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MomentumSourceTerm</span><span class="p">(</span><span class="n">ShallowWaterMomentumTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic source term in the shallow water momentum equation</span>

<span class="sd">    The weak form reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        F_s = \int_\Omega \boldsymbol{\tau} \cdot \boldsymbol{\psi} dx</span>

<span class="sd">    where :math:`\boldsymbol{\tau}` is a user defined vector valued :class:`Function`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="MomentumSourceTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.MomentumSourceTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">momentum_source</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;momentum_source&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">momentum_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">inner</span><span class="p">(</span><span class="n">momentum_source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="n">f</span></div>
</div>



<div class="viewcode-block" id="ContinuitySourceTerm">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ContinuitySourceTerm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ContinuitySourceTerm</span><span class="p">(</span><span class="n">ShallowWaterContinuityTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic source term in the depth-averaged continuity equation</span>

<span class="sd">    The weak form reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        F_s = \int_\Omega S \phi dx</span>

<span class="sd">    where :math:`S` is a user defined scalar :class:`Function`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ContinuitySourceTerm.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ContinuitySourceTerm.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">volume_source</span> <span class="o">=</span> <span class="n">fields_old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;volume_source&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">volume_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">inner</span><span class="p">(</span><span class="n">volume_source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="n">f</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">BathymetryDisplacementMassTerm</span><span class="p">(</span><span class="n">ShallowWaterContinuityTerm</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bathmetry mass displacement term, :math:`\partial \eta / \partial t + \partial \tilde{h} / \partial t`</span>

<span class="sd">    The weak form reads</span>

<span class="sd">    .. math::</span>
<span class="sd">        \int_\Omega ( \partial \eta / \partial t + \partial \tilde{h} / \partial t ) \phi dx</span>
<span class="sd">         = \int_\Omega (\partial \tilde{H} / \partial t) \phi dx</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">wd_bathymetry_displacement</span><span class="p">(</span><span class="n">eta</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta_test</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span>


<div class="viewcode-block" id="BaseShallowWaterEquation">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BaseShallowWaterEquation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseShallowWaterEquation</span><span class="p">(</span><span class="n">Equation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for ShallowWaterEquations, ShallowWaterMomentumEquation</span>
<span class="sd">    and FreeSurfaceEquation.</span>

<span class="sd">    Provides common functionality to compute time steps and add either momentum</span>
<span class="sd">    or continuity terms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_space</span><span class="p">,</span>
                 <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

<div class="viewcode-block" id="BaseShallowWaterEquation.add_momentum_terms">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BaseShallowWaterEquation.add_momentum_terms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_momentum_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">tidal_farms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">ExternalPressureGradientTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">HorizontalAdvectionTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">HorizontalViscosityTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;explicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">CoriolisTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">WindStressTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">AtmosphericPressureTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">QuadraticDragTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">LinearDragTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">BoundaryDragTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">BottomDrag3DTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">MomentumSourceTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tidal_farms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">TurbineDragTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">tidal_farms</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseShallowWaterEquation.add_continuity_terms">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BaseShallowWaterEquation.add_continuity_terms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_continuity_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">HUDivTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">ContinuitySourceTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseShallowWaterEquation.residual_uv_eta">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.BaseShallowWaterEquation.residual_uv_eta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual_uv_eta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_terms</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">term</span><span class="o">.</span><span class="n">residual</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span></div>
</div>



<div class="viewcode-block" id="ShallowWaterEquations">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterEquations">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ShallowWaterEquations</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D depth-averaged shallow water equations in non-conservative form.</span>

<span class="sd">    This defines the full 2D SWE equations :eq:`swe_freesurf` -</span>
<span class="sd">    :eq:`swe_momentum`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">tidal_farms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg function_space: Mixed function space where the solution belongs</span>
<span class="sd">        :arg depth: :class: `DepthExpression` containing depth info</span>
<span class="sd">        :arg options: :class:`.AttrDict` object containing all circulation model options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterEquations</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">function_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="n">u_test</span><span class="p">,</span> <span class="n">eta_test</span> <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span> <span class="o">=</span> <span class="n">function_space</span><span class="o">.</span><span class="n">subspaces</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_momentum_terms</span><span class="p">(</span><span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">tidal_farms</span><span class="o">=</span><span class="n">tidal_farms</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_continuity_terms</span><span class="p">(</span><span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_displacement_mass_term</span> <span class="o">=</span> <span class="n">BathymetryDisplacementMassTerm</span><span class="p">(</span>
            <span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

<div class="viewcode-block" id="ShallowWaterEquations.mass_term">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterEquations.mass_term">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mass_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterEquations</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">mass_term</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_displacement_mass_term</span><span class="o">.</span><span class="n">residual</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="ShallowWaterEquations.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterEquations.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">solution_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">solution_old</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_uv_eta</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ModeSplit2DEquations">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ModeSplit2DEquations">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ModeSplit2DEquations</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D depth-averaged shallow water equations for mode splitting schemes.</span>

<span class="sd">    Defines the equations :eq:`swe_freesurf_modesplit` -</span>
<span class="sd">    :eq:`swe_momentum_modesplit`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg function_space: Mixed function space where the solution belongs</span>
<span class="sd">        :arg depth: :class: `DepthExpression` containing depth info</span>
<span class="sd">        :arg options: :class:`.AttrDict` object containing all circulation model options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO remove include_grad_* options as viscosity operator is omitted</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ModeSplit2DEquations</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">function_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="n">u_test</span><span class="p">,</span> <span class="n">eta_test</span> <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span> <span class="o">=</span> <span class="n">function_space</span><span class="o">.</span><span class="n">subspaces</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_momentum_terms</span><span class="p">(</span><span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_continuity_terms</span><span class="p">(</span><span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

<div class="viewcode-block" id="ModeSplit2DEquations.add_momentum_terms">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ModeSplit2DEquations.add_momentum_terms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_momentum_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">ExternalPressureGradientTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;implicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">CoriolisTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;explicit&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">MomentumSourceTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">AtmosphericPressureTerm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModeSplit2DEquations.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ModeSplit2DEquations.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">solution_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">solution_old</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_uv_eta</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FreeSurfaceEquation">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.FreeSurfaceEquation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FreeSurfaceEquation</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D free surface equation :eq:`swe_freesurf` in non-conservative form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg eta_test: test function of the elevation function space</span>
<span class="sd">        :arg eta_space: elevation function space</span>
<span class="sd">        :arg u_space: velocity function space</span>
<span class="sd">        :arg function_space: Mixed function space where the solution belongs</span>
<span class="sd">        :arg depth: :class: `DepthExpression` containing depth info</span>
<span class="sd">        :arg options: :class:`.AttrDict` object containing all circulation model options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FreeSurfaceEquation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">eta_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_continuity_terms</span><span class="p">(</span><span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_displacement_mass_term</span> <span class="o">=</span> <span class="n">BathymetryDisplacementMassTerm</span><span class="p">(</span>
            <span class="n">eta_test</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

<div class="viewcode-block" id="FreeSurfaceEquation.mass_term">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.FreeSurfaceEquation.mass_term">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mass_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">mass_term</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry_displacement_mass_term</span><span class="o">.</span><span class="n">residual</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">solution</span><span class="p">])</span>  <span class="c1"># expects [uv, eta] but uv is not used</span>
        <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="FreeSurfaceEquation.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.FreeSurfaceEquation.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">solution_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">uv</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>
        <span class="n">uv_old</span> <span class="o">=</span> <span class="n">fields_old</span><span class="p">[</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="n">eta_old</span> <span class="o">=</span> <span class="n">solution_old</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_uv_eta</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ShallowWaterMomentumEquation">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterMomentumEquation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ShallowWaterMomentumEquation</span><span class="p">(</span><span class="n">BaseShallowWaterEquation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D depth averaged momentum equation :eq:`swe_momentum` in non-conservative</span>
<span class="sd">    form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">tidal_farms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg u_test: test function of the velocity function space</span>
<span class="sd">        :arg u_space: velocity function space</span>
<span class="sd">        :arg eta_space: elevation function space</span>
<span class="sd">        :arg depth: :class: `DepthExpression` containing depth info</span>
<span class="sd">        :arg options: :class:`.AttrDict` object containing all circulation model options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ShallowWaterMomentumEquation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">u_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_momentum_terms</span><span class="p">(</span><span class="n">u_test</span><span class="p">,</span> <span class="n">u_space</span><span class="p">,</span> <span class="n">eta_space</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">tidal_farms</span><span class="o">=</span><span class="n">tidal_farms</span><span class="p">)</span>

<div class="viewcode-block" id="ShallowWaterMomentumEquation.residual">
<a class="viewcode-back" href="../../thetis.html#thetis.shallowwater_eq.ShallowWaterMomentumEquation.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">solution_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">):</span>
        <span class="n">uv</span> <span class="o">=</span> <span class="n">solution</span>
        <span class="n">uv_old</span> <span class="o">=</span> <span class="n">solution_old</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="s1">&#39;eta&#39;</span><span class="p">]</span>
        <span class="n">eta_old</span> <span class="o">=</span> <span class="n">fields_old</span><span class="p">[</span><span class="s1">&#39;eta&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_uv_eta</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">uv_old</span><span class="p">,</span> <span class="n">eta_old</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">fields_old</span><span class="p">,</span> <span class="n">bnd_conditions</span><span class="p">)</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2016-2025, Tuomas Kärnä et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>